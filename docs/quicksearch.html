<html>
<head>
</head>
<body style="background: transparent;">
    <script src="scripts/docstrap.lib.js"></script>
    <script src="scripts/lunr.min.js"></script>
    <script src="scripts/fulltext-search.js"></script>

    <script type="text/x-docstrap-searchdb">
    {"state.js.html":{"id":"state.js.html","title":"Source: state.js","body":" arco Modules ajaxcomponentsindexrouterselectorsstatestore Source: state.js // external dependencies import isFunction from 'lodash/isFunction'; import isPlainObject from 'lodash/isPlainObject'; import isString from 'lodash/isString'; import noop from 'lodash/noop'; import { createAction as createReduxAction, handleActions } from 'redux-actions'; // selectors import { getIdentityValue } from './selectors'; // constants import { STATUS, keys } from './constants'; let moduleCache = {}; /** * @module state */ /** * @private * * @function asyncErrorActionCreator * * @description * create action that will dispatch with the error status as meta * * @returns {{status: string}} */ export const asyncErrorActionCreator = () =&gt; { return { status: STATUS.ERROR }; }; /** * @private * * @function asyncRequestActionCreator * * @description * create action that will dispatch with the pending status as meta * * @returns {{status: string}} */ export const asyncRequestActionCreator = () =&gt; { return { status: STATUS.PENDING }; }; /** * @private * * @function asyncSuccessActionCreator * * @description * create action that will dispatch with the success status as meta * * @returns {{status: string}} */ export const asyncSuccessActionCreator = () =&gt; { return { status: STATUS.SUCCESS }; }; /** * @function getActionConstants * * @description * get the constants for the actions of a given namespace * * @example * import { * getActionConstants * } from 'arco'; * * // use the string namespace value * const ACTION_TYPES = getActionContents('app'); * * // or a predefined module * const ACTION_TYPES = getActionContents(appModule); * * @param {Object|string} namespace module or namespace that action constants are a member of * @returns {Object} */ export const getActionConstants = (namespace) =&gt; { if (isPlainObject(namespace)) { namespace = namespace.namespace; } const module = moduleCache[namespace]; if (!module) { return {}; } return keys(module.actions).reduce((constants, key) =&gt; { return { ...constants, [key]: module.actions[key].constantName }; }, {}); }; /** * @private * * @function getCreateAction * * @description * get the create action creator for a given namespace * * @param {string} namespace namespace action will reside in * @returns {function} */ export const getCreateAction = (namespace) =&gt; { /** * @function createAction * * @description * action creator helper that will return the redux-actions * action build based on its parameters * * @example * import { * createModule * } from 'arco'; * * const module = createModule('foo'); * * const action = module.createAction('SET_NAME'); * * @param {string} name name of the action * @param {function} [payloadCreator=getIdentityValue] method to handle the passing of the payload * @param {function|null} [metaCreator=null] method to handle any additional metadata * @returns {function} */ return (name, payloadCreator = getIdentityValue, metaCreator = null) =&gt; { if (!isString(name)) { throw new TypeError('Name of action must be a string.'); } const constantName = `${namespace}/${name}`; const action = createReduxAction(constantName, payloadCreator, metaCreator); moduleCache[namespace].actions[name] = { action, constantName }; return action; }; }; /** * @private * * @function getCreateAsyncAction * * @description * get the create async action creator for a given namespace * * @param {string} namespace namespace action will reside in * @returns {function} */ const getCreateAsyncAction = (namespace) =&gt; { const createAction = getCreateAction(namespace); /** * @function createAsyncAction * * @description * async action creator helper that creates a distinct action for each * status with the status passed via payload, and injects the functions * for each * * @example * import { * createModule, * get * } from 'arco'; * * const module = createModule('foo'); * * const action = module.createAsyncAction('GET_STUFF', (lifecycle, otherData) =&gt; { * const { * onError, * onRequest, * onSuccess * } = lifecycle; * * return (dispatch) =&gt; { * dispatch(onRequest(otherData)); * // otherData is passed as payload, PENDING is passed as status in meta * * return get('/foo') * .then((data) =&gt; { * dispatch(onSuccess(data)); * // data is passed as payload, SUCCESS is passed as status in meta * }) * .catch((error) =&gt; { * dispatch(onError(error)); * // error is passed as payload, ERROR is passed as status in meta * }); * }; * }); * * @param {string} name name of the action * @param {function} payloadHandler method to handle the passing of the payload * @returns {function} */ return (name, payloadHandler) =&gt; { if (!isString(name)) { throw new TypeError('Name of action must be a string.'); } const onError = createAction(name, getIdentityValue, asyncErrorActionCreator); const onRequest = createAction(name, getIdentityValue, asyncRequestActionCreator); const onSuccess = createAction(name, getIdentityValue, asyncSuccessActionCreator); const lifecycle = { onError, onRequest, onSuccess }; const action = (...args) =&gt; { return payloadHandler(lifecycle, ...args); }; //in case you want different handlers in the reducer for each action status action.onError = onError; action.onRequest = onRequest; action.onSuccess = onSuccess; /** * set the toString to return the name passed, so it will work * with createReducer * * @returns {string} */ action.toString = () =&gt; { return name; }; return action; }; }; /** * @private * * @function getCreateReducer * * @description * get the reducer creator for a given namespace * * @param {string} namespace namespace reducer will reside in * @returns {function} */ const getCreateReducer = (namespace) =&gt; { /** * @function createReducer * * @description * reducer creator that will accept the initialState and the handler of that * function, either as standard function or as redux-actions map * * @example * import { * getActionConstants * } from 'arco'; * * import module, { * setName * } from './actions'; * * const INITIAL_STATE = { * name: '' * }; * * // use the handleActions method from redux-actions * module.createReducer(INITIAL_STATE, (state, { * [setName](state, {payload}) { * return { * ...state, * name: payload * }; * } * }); * * // or use the traditional reducer function method, which requires converting the actions toString * module.createReducer(INITIAL_STATE, (state, {payload, type}) =&gt; { * switch (type) { * case `${setName}`: * return { * ...state, * name: payload * }; * * default: * return state; * } * }); * * @param {Object} initialState initial state to hydrate store with * @param {function} handler method to handle state updates * @returns {function} */ return (initialState, handler) =&gt; { const reducer = !isFunction(handler) ? handleActions(handler, initialState) : (state = initialState, action) =&gt; { return handler(state, action); }; moduleCache[namespace].reducer = reducer; reducer.namespace = namespace; return reducer; }; }; /** * @function createModule * * @description * create a module which has actions and a reducer, and has create methods for them * * @example * import { * createModule * } from 'arco'; * * const appModule = createModule('app'); * * @param {string} namespace namespace for the module * @returns {Object} */ export const createModule = (namespace) =&gt; { if (!isString(namespace)) { throw new TypeError('Namespace provided must be a string.'); } if (moduleCache[namespace]) { throw new ReferenceError(`Namespace ${namespace} is already in use.`); } moduleCache[namespace] = { actions: {}, reducer: noop }; const createAction = getCreateAction(namespace); const createAsyncAction = getCreateAsyncAction(); const createReducer = getCreateReducer(namespace); return { createAction, createAsyncAction, createReducer, namespace }; }; /** * @function getModules * * @description * get the module for the given namespace, or all modules if none * * @example * import { * getModules * } from 'arco'; * * const allModules = getModules(); * const appModule = getModules('app'); * * @param {string} namespace namespace of module to retrieve * @returns {Object} */ export const getModules = (namespace) =&gt; { if (isString(namespace)) { return moduleCache[namespace]; } return moduleCache; }; export default createModule; × Search results Close Documentation generated by JSDoc 3.4.3 using the DocStrap template. "},"ajax.js.html":{"id":"ajax.js.html","title":"Source: ajax.js","body":" arco Modules ajaxcomponentsindexrouterselectorsstatestore Source: ajax.js // external dependencies import axios from 'axios'; import isPlainObject from 'lodash/isPlainObject'; // utils import { keys } from './utils'; /** * @module ajax */ /** * @function createInstance * * @description * create a unique axios instance based on the options passed * * @example * import { * createInstance * } from 'arco'; * * const ajaxInstance = createInstance({ * baseURL: 'http://foo.com' * }); * * @param {Object} [options] axios options to pass to the instance when created * @returns {AxiosInstance} */ export const createInstance = (options = {}) =&gt; { return axios.create(options); }; /* eslint-disable valid-jsdoc */ /** * @function setDefaults * * @description * set the defaults for the axios instance * * @example * import { * setDefaults * } from 'arco'; * * setDefaults({ * baseURL: 'http://foo.com', * headers: { * 'X-API-Key': 'bar' * } * }); * * @param {Object} [options={}] * @param {string} [options.baseURL] base URL for all axios calls * @param {Object} [options.headers] headers to add to all axios calls * @returns {Axios} */ /* eslint-enable */ export const setDefaults = ({baseURL, headers} = {}) =&gt; { if (baseURL) { axios.defaults.baseURL = baseURL; } if (isPlainObject(headers)) { const { del, get, head, patch, post, put, ...common } = headers; axios.defaults.headers.delete = del; axios.defaults.headers.get = get; axios.defaults.headers.head = head; axios.defaults.headers.patch = patch; axios.defaults.headers.post = post; axios.defaults.headers.put = put; keys(common).forEach((key) =&gt; { axios.defaults.headers.common[key] = common[key]; }); } return axios; }; /** * @function del * * @description * perform DELETE call via AJAX * * @example * import { * del * } from 'arco'; * * const response = del('/foo/1234'); * * @param {string} url URL to submit DELETE to * @param {Object} [config] custom configuration options for specific call * @returns {Promise} */ export const del = axios.delete; /** * @function get * * @description * perform GET call via AJAX * * @example * import { * get * } from 'arco'; * * const response = get('/foo/1234'); * * @param {string} url URL to submit GET to * @param {Object} [config] custom configuration options for specific call * @returns {Promise} */ export const get = axios.get; /** * @function head * * @description * perform HEAD call via AJAX * * @example * import { * head * } from 'arco'; * * const response = head('/foo'); * * @param {string} url URL to submit HEAD to * @param {Object} [config] custom configuration options for specific call * @returns {Promise} */ export const head = axios.head; /** * @function patch * * @description * perform PATCH call via AJAX * * @example * import { * patch * } from 'arco'; * * const response = patch('/foo/123'); * * @param {string} url URL to submit PATCH to * @param {Object} [data] data to include in the request body on the call * @param {Object} [config] custom configuration options for specific call * @returns {Promise} */ export const patch = axios.patch; /** * @function post * * @description * perform POST call via AJAX * * @example * import { * post * } from 'arco'; * * const response = post('/foo/123', { * bar: 'baz' * }); * * @param {string} url URL to submit POST to * @param {Object} [data] data to include in the request body on the call * @param {Object} [config] custom configuration options for specific call * @returns {Promise} */ export const post = axios.post; /** * @function put * * @description * perform PUT call via AJAX * * @example * import { * put * } from 'arco'; * * const response = put('/foo/123', { * bar: 'foo' * }); * * @param {string} url URL to submit PUT to * @param {Object} [data] data to include in the request body on the call * @param {Object} [config] custom configuration options for specific call * @returns {Promise} */ export const put = axios.put; export default { createInstance, del, get, head, patch, post, put, setDefaults }; × Search results Close Documentation generated by JSDoc 3.4.3 using the DocStrap template. "},"components.js.html":{"id":"components.js.html","title":"Source: components.js","body":" arco Modules ajaxcomponentsindexrouterselectorsstatestore Source: components.js // external dependencies import isFunction from 'lodash/isFunction'; import React, { Component as ReactComponent } from 'react'; import { findDOMNode } from 'react-dom'; import { connect } from 'react-redux'; // constants import { keys } from './constants'; // utils import { getComponentMethods, getPropsAndMethods, isReactClass, isReactEvent, memoize } from './utils'; /** * @module components */ /** * @private * * @function addPropertyIfExists * * @description * add to component the property if the value exists * * @param {ReactComponent} component component to add the property to * @param {string} property property name * @param {*} value value of the property to assign * @returns {ReactComponent} */ export const addPropertyIfExists = (component, property, value) =&gt; { if (!!value) { component[property] = value; } return component; }; /** * @private * * @function assignChildContext * * @description * assign the child context to the component passed * * @param {ReactComponent} component component to assign child context to * @param {function} getChildContext method for getting child context * @returns {ReactComponent} */ export const assignChildContext = (component, getChildContext) =&gt; { component.getChildContext = function() { return getChildContext(component.props, component.context); }; return component; }; /** * @private * * @function assignInstanceValues * * @description * assign the instance values to the component passed * * @param {ReactComponent} component component to assign instance values to * @returns {ReactComponent} */ export const assignInstanceValues = (component) =&gt; { component.getPropsToPass = memoize(getPropsAndMethods); component.methods = {}; return component; }; /** * @private * * @function connectIfReduxPropertiesExist * * @description * if there are redux-specific options present, connect the component * * @param {ReactComponent} component component to connect to redux if applicable * @param {function|Object} mapDispatchToProps functions wrapped in dispatch to pass as props * @param {function} mapStateToProps state to pass as props * @param {function} mergeProps function to merge store state with local props * @param {Object} reduxOptions additional options to pass to @connect * @returns {ReactComponent} */ export const connectIfReduxPropertiesExist = (component, { mapDispatchToProps, mapStateToProps, mergeProps, reduxOptions }) =&gt; { if (mapDispatchToProps || mapStateToProps || mergeProps || reduxOptions) { return connect(mapStateToProps, mapDispatchToProps, mergeProps, reduxOptions)(component); } return component; }; /** * @private * * @function hasGetPropsToPass * * @description * does the component contain the getPropsToPass method * * @param {function} getPropsToPass method to get all props to pass down * @returns {boolean} */ export const hasGetPropsToPass = ({getPropsToPass}) =&gt; { return isFunction(getPropsToPass); }; /** * @private * * @function assignLifecycleMethods * * @description * assign the lifecycle methods to the instance * * @param {ReactComponent|StatefulComponent} component component to assign lifecycle methods to * @param {Object} lifecycleMethods map of lifecycle methods * @returns {ReactComponent} */ export const assignLifecycleMethods = (component, lifecycleMethods) =&gt; { const getAllProps = () =&gt; { if (hasGetPropsToPass(component)) { return component.getPropsToPass(component.props, component.methods); } return component.props; }; keys(lifecycleMethods).forEach((key) =&gt; { component[key] = function(props, state, context) { let args = [getAllProps()]; if (props) { args.push(props); } args.push(component.context, context); return lifecycleMethods[key](...args); }; }); return component; }; /** * @private * * @function assignLocalMethods * * @description * assign the local methods to the instance * * @param {ReactComponent} component component to assign local methods to * @param {Object} localMethods map of methods accessible locally through props * @returns {ReactComponent} */ export const assignLocalMethods = (component, localMethods) =&gt; { const getAllProps = () =&gt; { if (hasGetPropsToPass(component)) { return component.getPropsToPass(component.props, component.methods); } return component.props; }; keys(localMethods).forEach((key) =&gt; { component.methods[key] = (...args) =&gt; { const [ event, ...restOfArgs ] = args; const isFirstArgEvent = isReactEvent(event); let argsToPass = [getAllProps()]; if (isFirstArgEvent) { argsToPass.unshift(event); } argsToPass.push(component.context); argsToPass.push(isFirstArgEvent ? restOfArgs : args); return localMethods[key].apply(undefined, argsToPass); }; }); component.methods.getDOMNode = () =&gt; { return findDOMNode(component); }; return component; }; /** * @private * * @function getStatefulComponent * * @description * get the stateful component that, if the options are passed, is connected to redux * * @param {Component} PassedComponent component wrapped by arco * @param {Object} options options to apply to the HOC created by arco * @returns {Component} */ export const getStatefulComponent = (PassedComponent, options) =&gt; { const { childContextTypes, contextTypes, getChildContext, mapDispatchToProps: mapDispatchToPropsIgnored, mapStateToProps: mapStateToPropsIgnored, mergeProps: mergePropsIgnored, propTypes, reduxOptions: reduxOptionsIgnored, ...restOfOptions } = options; const { lifecycleMethods } = getComponentMethods(restOfOptions); class StatefulComponent extends PassedComponent { constructor(...args) { super(...args); assignLifecycleMethods(this, lifecycleMethods); if (childContextTypes &amp;&amp; getChildContext) { assignChildContext(this, getChildContext); } } render() { return super.render(); } } addPropertyIfExists(StatefulComponent, 'childContextTypes', childContextTypes); addPropertyIfExists(StatefulComponent, 'contextTypes', contextTypes); addPropertyIfExists(StatefulComponent, 'propTypes', propTypes); return connectIfReduxPropertiesExist(StatefulComponent, options); }; /** * @private * * @function getStatelessComponent * * @description * get the stateless component HOC that has local and lifecycle methods based on * the options, as well as possibly being connected to redux * * @param {function} PassedComponent component wrapped by arco * @param {Object} options options to apply to the HOC created by arco * @returns {Component} */ export const getStatelessComponent = (PassedComponent, options) =&gt; { const { childContextTypes, contextTypes, getChildContext, mapDispatchToProps: mapDispatchToPropsIgnored, mapStateToProps: mapStateToPropsIgnored, mergeProps: mergePropsIgnored, propTypes, reduxOptions: reduxOptionsIgnored, ...restOfOptions } = options; const { lifecycleMethods, localMethods } = getComponentMethods(restOfOptions); addPropertyIfExists(PassedComponent, 'contextTypes', contextTypes); addPropertyIfExists(PassedComponent, 'propTypes', propTypes); class StatelessComponent extends ReactComponent { constructor(...args) { super(...args); assignInstanceValues(this); assignLifecycleMethods(this, lifecycleMethods); assignLocalMethods(this, localMethods); if (childContextTypes &amp;&amp; getChildContext) { assignChildContext(this, getChildContext); } } render() { const propsToPass = this.getPropsToPass(this.props, this.methods); return ( &lt;PassedComponent {...propsToPass}/&gt; ); } } addPropertyIfExists(StatelessComponent, 'childContextTypes', childContextTypes); return connectIfReduxPropertiesExist(StatelessComponent, options); }; /** * @function createComponent * * @description * create a simple component where props are rendered * * @example * import createComponent from 'arco'; * * const OPTIONS = { * onButtonClick() { * alert('hello!'); * } * }; * * const Foo = ({onButtonClick}) =&gt; { * return ( * &lt;button * onClick={onButtonClick} * type=&quot;button&quot; * &gt; * Click me! * &lt;/button&gt; * ); * }; * * export default createComponent(Foo, OPTIONS); * * @param {Component|function} PassedComponent component to wrap * @param {Object} [options={}] options to apply to the HOC created by arco * @returns {Component|function(Component): Component} */ export const createComponent = (PassedComponent, options = {}) =&gt; { if (isReactClass(PassedComponent)) { return getStatefulComponent(PassedComponent, options); } return getStatelessComponent(PassedComponent, options); }; export {ReactComponent as StatefulComponent}; export default createComponent; × Search results Close Documentation generated by JSDoc 3.4.3 using the DocStrap template. "},"index.js.html":{"id":"index.js.html","title":"Source: index.js","body":" arco Modules ajaxcomponentsindexrouterselectorsstatestore Source: index.js // external dependencies import React, { PropTypes } from 'react'; import { findDOMNode, render as ReactRender } from 'react-dom'; import { Provider } from 'react-redux'; // components import createComponent, { StatefulComponent } from './components'; // modules import createModule, { getActionConstants } from './state'; // store import createStore from './store'; // ajax import ajax, { createInstance, del, get, head, patch, post, put, setDefaults } from './ajax'; // router import { IndexLink, IndexRedirect, IndexRoute, Link, Route, Router, RouterContext, applyRouterMiddleware, createRoutes, createHistory, formatPattern, locationShape, match, routerShape, syncHistoryWithStore, withRouter } from './router.js'; // selectors import createSelector from './selectors'; /** * @module index */ /** * @function render * * @description * render the passed component with the provided store * * @example * import { * render * } from 'arco'; * * import App from './App'; * import store from './store'; * * render(( * &lt;App/&gt; * ), document.querySelector('#app'), store); * * @param {React.Component} Component component to render in element * @param {HTMLElement} element HTML element to render Component inside of * @param {Object} store redux store to pass to all components */ export const render = (Component, element, store) =&gt; { ReactRender(( &lt;Provider store={store}&gt; {Component} &lt;/Provider&gt; ), element); }; export {StatefulComponent}; export {createComponent}; export {PropTypes}; export {createModule}; export {getActionConstants}; export {createStore}; export {ajax}; export {createInstance}; export {del}; export {get}; export {head}; export {patch}; export {post}; export {put}; export {setDefaults}; export {IndexLink}; export {IndexRedirect}; export {IndexRoute}; export {Link}; export {Route}; export {Router}; export {RouterContext}; export {applyRouterMiddleware}; export {createRoutes}; export {createHistory}; export {formatPattern}; export {locationShape}; export {match}; export {routerShape}; export {syncHistoryWithStore}; export {withRouter}; export {React}; export {findDOMNode}; export {React as jsx}; export {createSelector}; export default createComponent; × Search results Close Documentation generated by JSDoc 3.4.3 using the DocStrap template. "},"router.js.html":{"id":"router.js.html","title":"Source: router.js","body":" arco Modules ajaxcomponentsindexrouterselectorsstatestore Source: router.js // external dependencies import isFunction from 'lodash/isFunction'; import { IndexLink, IndexRedirect, IndexRoute, Link, Route, Router, RouterContext, applyRouterMiddleware, browserHistory, createMemoryHistory, createRoutes, formatPattern, hashHistory, locationShape, match, routerShape, useRouterHistory, withRouter } from 'react-router'; import { syncHistoryWithStore } from 'react-router-redux'; const HISTORY_TYPES = { BROWSER: 'browser', HASH: 'hash', MEMORY: 'memory' }; /** * @module router */ /** * @function createHistory * * @description * pass the internal react-router pieces necessary to build a custom history * * @example * import { * createHistory * } from 'arco'; * * // create using the string shorthand * // valid values are &quot;browser&quot;, &quot;hash&quot;, &quot;memory&quot; * const history = createHistory('browser'); * * // or with a custom function * const history = createHistory(({hashHistory, useRouterHistory}) =&gt; { * return useRouterHistory(hashHistory)({ * queryKey: false * }); * }); * * @param {function|string} [history=browser] type of history to create * @param {Object} [memoryHistoryOptions] options specific to creating a memory history * @returns {Object} */ export const createHistory = (history = HISTORY_TYPES.BROWSER, memoryHistoryOptions) =&gt; { if (history === HISTORY_TYPES.BROWSER) { return browserHistory; } if (history === HISTORY_TYPES.HASH) { return hashHistory; } if (history === HISTORY_TYPES.MEMORY) { return createMemoryHistory(memoryHistoryOptions); } if (isFunction(history)) { return history({ browserHistory, createMemoryHistory, formatPattern, hashHistory, match, useRouterHistory }); } throw new ReferenceError('History does not match any known values, and you are not attempting to create' + 'your own custom history.'); }; export {IndexLink}; export {IndexRedirect}; export {IndexRoute}; export {Link}; export {Route}; export {Router}; export {RouterContext}; export {applyRouterMiddleware}; export {createRoutes}; export {formatPattern}; export {locationShape}; export {match}; export {routerShape}; export {syncHistoryWithStore}; export {withRouter}; export default createHistory; × Search results Close Documentation generated by JSDoc 3.4.3 using the DocStrap template. "},"selectors.js.html":{"id":"selectors.js.html","title":"Source: selectors.js","body":" arco Modules ajaxcomponentsindexrouterselectorsstatestore Source: selectors.js // external dependencies import isArray from 'lodash/isArray'; import isFunction from 'lodash/isFunction'; import isPlainObject from 'lodash/isPlainObject'; import toPath from 'lodash/toPath'; import { createSelector as createReselectSelector, createSelectorCreator } from 'reselect'; // utils import { getNestedValueFromObject } from './utils'; /** * @module selectors */ /** * @private * * @function createIdentitySelector * * @description * create selector to retrieve identity based on deeply-nested values * * @param {function|string} property property string to convert to nested path * @returns {function(Object): *} */ export const createIdentitySelector = (property) =&gt; { if (isFunction(property)) { return property; } const pathProperties = toPath(property); return (passedState) =&gt; { return getNestedValueFromObject(passedState, pathProperties); }; }; /** * @private * * @function getIdentityValue * * @description * pass-through function to return the value passed to it * * @param {*} value value to pass through * @returns {*} */ export const getIdentityValue = (value) =&gt; { return value; }; /** * @private * * @function getStructuredValue * * @description * build a structured value to return for structured selectors * * @param {Array&lt;string&gt;} keys array of keys to use for values in structured selector * @returns {function(Array&lt;*&gt;): Object} */ export const getStructuredValue = (keys) =&gt; { return (...values) =&gt; { return keys.reduce((structuredValue, key, keyIndex) =&gt; { structuredValue[key] = values[keyIndex]; return structuredValue; }, {}); }; }; /** * @private * * @function getStandardSelector * * @description * get the standard selector type (single value) * * @param {Array&lt;string&gt;} paths array of strings denoting nested paths of values in state * @param {function} selectorGenerator method to use for generating selector * @param {function} getValue method to use for computing the value to return * @returns {function} */ export const getStandardSelector = (paths, selectorGenerator, getValue) =&gt; { const selectors = paths.map(createIdentitySelector); return selectorGenerator(selectors, getValue); }; /* eslint-disable valid-jsdoc */ /** * @private * * @function getStructuredSelector * * @description * get the structured selector based on the properties passed * * @param {Array&lt;string&gt;} keys array of keys to use for values in structured selector * @param {Array&lt;string&gt;} paths array of strings denoting nested paths to use for values in structured selector * @param {function} selectorGenerator method to use for generating selector * @returns {function} */ /* eslint-enable */ export const getStructuredSelector = ({keys, paths}, selectorGenerator) =&gt; { if (keys.length !== paths.length) { throw new ReferenceError('Keys and properties arrays must be the same length.'); } const selectors = paths.map(createIdentitySelector); return selectorGenerator(selectors, getStructuredValue(keys)); }; /** * @function createSelector * * @description * based on the array of properties and the reducer passed * create a selector * * @example * import { * createSelector * } from 'arco'; * * const hasBaz = createSelector(['foo.bar[0].baz'], (baz) =&gt; { * return !!baz; * }); * * hasBaz({foo: {bar: [{ baz: 'Here!'}]}}); // true * hasBaz({foo: {bar: [{ baz: 'Here!'}]}}); // true, pulled from cache * * @param {Array&lt;string&gt;|{keys: Array&lt;string&gt;, paths: Array&lt;string&gt;}} properties properties to retrieve from state * @param {function} [getComputedValue=getIdentityValue] method to use for getting the computed value from the properties * @param {function} [customMemoize=null] custom memoizer function to use in place of the default * @param {function} [customMemoizeOptions=null] additional options for using the custom memoizer option * @returns {function} */ export const createSelector = ( properties = [], getComputedValue = getIdentityValue, customMemoize = null, customMemoizeOptions = null ) =&gt; { const selectorGenerator = isFunction(customMemoize) ? createSelectorCreator(customMemoize, ...customMemoizeOptions) : createReselectSelector; if (isPlainObject(properties)) { return getStructuredSelector(properties, selectorGenerator); } if (!isArray(properties)) { throw new TypeError('Properties passed must be either an object of keys and paths or an array of paths.'); } return getStandardSelector(properties, selectorGenerator, getComputedValue); }; export default createSelector; × Search results Close Documentation generated by JSDoc 3.4.3 using the DocStrap template. "},"store.js.html":{"id":"store.js.html","title":"Source: store.js","body":" arco Modules ajaxcomponentsindexrouterselectorsstatestore Source: store.js // external dependencies import isArray from 'lodash/isArray'; import isFunction from 'lodash/isFunction'; import { routerReducer } from 'react-router-redux'; import { applyMiddleware, combineReducers, compose, createStore as createReduxStore } from 'redux'; import reduxThunk from 'redux-thunk'; // modules import { getModules } from './state'; // constants import { ARCO_STATE_KEY } from './constants'; const DEFAULT_REDUCERS_WITH_HISTORY = { routing: routerReducer }; /** * @module store */ /** * @private * * @function addWindowUnloadListener * * @description * add a listener to beforeunload to save the state in sessionStorage * * @param {Object} store state to store in sessionStorage for retrieval on refresh */ export const addWindowUnloadListener = (store) =&gt; { window.addEventListener('beforeunload', () =&gt; { const state = store.getState(); window.sessionStorage.setItem(ARCO_STATE_KEY, JSON.stringify(state)); }); }; /** * @private * * @function createRestorableStateStore * * @description * create a store that will automatically save and restore the state * in session storage * * @param {function} reducers all reducers to be used in the store creation * @param {function} enhancers all enhancers to be used in the store creation * @param {Object} initialState state to hydrate the store with on creation * @returns {Store} */ export const createRestorableStateStore = (reducers, enhancers, initialState) =&gt; { const stateString = window &amp;&amp; window.sessionStorage.getItem(ARCO_STATE_KEY); const preloadedState = stateString ? JSON.parse(stateString) : {...initialState}; const store = createReduxStore(reducers, preloadedState, enhancers); if (window) { addWindowUnloadListener(store); } return store; }; /** * @private * * @function getEnhancers * * @description * get the enhancers used in the store based on the middlewares passed * and if thunk is to be included * * @param {Array&lt;function&gt;} middlewares array of middlewares to be applied to the store * @param {boolean} hasThunk whether to use redux-thunk middleware * @returns {function} */ export const getEnhancers = (middlewares = [], hasThunk) =&gt; { let enhancers = [...middlewares]; if (hasThunk) { enhancers.unshift(reduxThunk); } if (!enhancers.length) { return undefined; } const composeEnhancers = (window &amp;&amp; window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__) || compose; return composeEnhancers(applyMiddleware(...enhancers)); }; /** * @private * * @function getReducerMap * * @description * get the map of reducers based on the modules / reducers * passed and whether or not to include the routing reducer * * @param {Array&lt;Object|function&gt;} modules array of modules or reducers to populate the store with * @param {boolean} hasHistory whether a history object exists, and therefore should have a router reducer * @returns {Object} */ export const getReducerMap = (modules, hasHistory) =&gt; { let moduleMap = hasHistory ? DEFAULT_REDUCERS_WITH_HISTORY : {}; return modules.reduce((reducers, passedReducer) =&gt; { const namespace = passedReducer.namespace; const module = isFunction(passedReducer) ? passedReducer : getModules(namespace); if (!module) { return reducers; } if (isFunction(module)) { return { ...reducers, [namespace]: module }; } return { ...reducers, [namespace]: module.reducer }; }, moduleMap); }; /** * @function createStore * * @description * create a store based on the options passed * * @example * import { * createStore * } from 'arco'; * * import appModule from 'modules/app'; * import fooModule from 'modules/foo'; * import barModule from 'modules/bar'; * * const store = createStore([appModule, fooModule, barModule], { * shouldRestoreState: true * }); * * @param {Array&lt;Object|function&gt;} modules array of modules or reducers to use in the store creation * @param {boolean} [autoRestore=false] whether the state should be kept in sessionStorage and automatically restored * @param {Object} history history object to use for creation of the store * @param {Object} [initialState={}] state to hydrate the store with upon creation * @param {Array&lt;Object|function&gt;} [middlewares=[]] array of middlewares to use in the store creation * @param {boolean} [thunk=true] whether to include redux-thunk in the middlewares used in the store creation * @returns {Store} */ export const createStore = (modules, { autoRestore = false, history, initialState = {}, middlewares = [], thunk = true }) =&gt; { if (!isArray(modules)) { throw new TypeError('The first parameter must be an array of modules.'); } const mapOfReducers = getReducerMap(modules, !!history); const allReducers = combineReducers(mapOfReducers); const enhancers = getEnhancers(middlewares, thunk); if (!autoRestore) { return createReduxStore(allReducers, initialState, enhancers); } return createRestorableStateStore(allReducers, enhancers, initialState); }; export default createStore; × Search results Close Documentation generated by JSDoc 3.4.3 using the DocStrap template. "},"modules.list.html":{"id":"modules.list.html","title":"Modules","body":" arco Modules ajaxcomponentsindexrouterselectorsstatestore Modules × Search results Close Documentation generated by JSDoc 3.4.3 using the DocStrap template. "},"index.html":{"id":"index.html","title":"Index","body":" arco Modules ajaxcomponentsindexrouterselectorsstatestore arco 0.1.0 arcoA React+Redux framework to ease the fatigue Installation$ npm i arco --saveSummaryarco is a framework designed to streamline a lot of the architectural configuration of a React application by providing several web-standard packages built-in, as well as an API that is built to keep boilerplate minimal. The following packages are all included as part of arco: react for views react-dom for rendering into the browser react-router for routing react-router-redux for react-router bindings into redux redux for state management redux-actions for simplified redux action creation redux-thunk for asynchronous actions (optional) reselect for memoized selectors arco provides a layer of abstraction over the use of these so that you can focus on implementation, but with the same sort of flexibility you would expect from each of these packages directly. Think of it as convention with configuration. Additionally, keeping in line with redux, there is a focus on immutability and pure functions. Notice in the usage example below that App has lifecycle methods and an instance method with access to props even though it is a functional component. This is explained more in detail below. UsageA full application (with store, actions, and reducer) in 64 lines: import createComponent, { createHistory, createModule, createStore, render } from 'arco'; // create a module const appModule = createModule('app'); // create actions for that module const increaseCount = appModule.createAction('INCREASE_COUNT', (currentCount) =&gt; { return currentCount + 1; }); // create a reducer for that module const reducer = appModule.createReducer({count: 0}, { [increaseCount](state, {payload}) { return { ...state, count: payload }; } }); // create your component const App = ({count, onClickButton}) =&gt; { return ( &lt;main&gt; &lt;div&gt; Current count: {count} &lt;/div&gt; &lt;button onClick={onClickButton} type=&quot;button&quot; &gt; Click to increase the count &lt;/button&gt; &lt;/main&gt; ); }; // give it options const ConnectedApp = createComponent(App, { mapStateToProps({app}) { return app; }, mapDispatchToProps: { increaseCount }, onClickButton(e, {count, increaseCount}) { increaseCount(count); } }); // create your store const store = createStore([appModule], { history: createHistory() }); // render render(( &lt;App/&gt; ), document.body, store);The biggest change from what you are used to is probably the options we pass to create ConnectedApp. Internally, arco creates lifecycle and standard methods where the props and context are passed in as parameters to the method (rather than accessing them through the this reference to the instance). This allows you to write your lifecycle and instance methods as pure functions, making them both more testable and free of side effects. The full range of options is covered on the documentation site. × Search results Close Documentation generated by JSDoc 3.4.3 using the DocStrap template. "},"module-ajax.html":{"id":"module-ajax.html","title":"Module: ajax","body":" arco Modules ajaxcomponentsindexrouterselectorsstatestore Module: ajax Source: ajax.js, line 10 Methods &lt;inner&gt; createInstance( [options]) create a unique axios instance based on the options passed Parameters: Name Type Argument Description options Object &lt;optional&gt; axios options to pass to the instance when created Source: ajax.js, line 14 Returns: Type AxiosInstance Example import { createInstance } from 'arco'; const ajaxInstance = createInstance({ baseURL: 'http://foo.com' }); &lt;inner&gt; del(url [, config]) perform DELETE call via AJAX Parameters: Name Type Argument Description url string URL to submit DELETE to config Object &lt;optional&gt; custom configuration options for specific call Source: ajax.js, line 92 Returns: Type Promise Example import { del } from 'arco'; const response = del('/foo/1234'); &lt;inner&gt; get(url [, config]) perform GET call via AJAX Parameters: Name Type Argument Description url string URL to submit GET to config Object &lt;optional&gt; custom configuration options for specific call Source: ajax.js, line 111 Returns: Type Promise Example import { get } from 'arco'; const response = get('/foo/1234'); &lt;inner&gt; head(url [, config]) perform HEAD call via AJAX Parameters: Name Type Argument Description url string URL to submit HEAD to config Object &lt;optional&gt; custom configuration options for specific call Source: ajax.js, line 130 Returns: Type Promise Example import { head } from 'arco'; const response = head('/foo'); &lt;inner&gt; patch(url [, data] [, config]) perform PATCH call via AJAX Parameters: Name Type Argument Description url string URL to submit PATCH to data Object &lt;optional&gt; data to include in the request body on the call config Object &lt;optional&gt; custom configuration options for specific call Source: ajax.js, line 149 Returns: Type Promise Example import { patch } from 'arco'; const response = patch('/foo/123'); &lt;inner&gt; post(url [, data] [, config]) perform POST call via AJAX Parameters: Name Type Argument Description url string URL to submit POST to data Object &lt;optional&gt; data to include in the request body on the call config Object &lt;optional&gt; custom configuration options for specific call Source: ajax.js, line 169 Returns: Type Promise Example import { post } from 'arco'; const response = post('/foo/123', { bar: 'baz' }); &lt;inner&gt; put(url [, data] [, config]) perform PUT call via AJAX Parameters: Name Type Argument Description url string URL to submit PUT to data Object &lt;optional&gt; data to include in the request body on the call config Object &lt;optional&gt; custom configuration options for specific call Source: ajax.js, line 191 Returns: Type Promise Example import { put } from 'arco'; const response = put('/foo/123', { bar: 'foo' }); &lt;inner&gt; setDefaults( [options]) set the defaults for the axios instance Parameters: Name Type Argument Default Description options Object &lt;optional&gt; {} Properties Name Type Argument Description baseURL string &lt;optional&gt; base URL for all axios calls headers Object &lt;optional&gt; headers to add to all axios calls Source: ajax.js, line 37 Returns: Type Axios Example import { setDefaults } from 'arco'; setDefaults({ baseURL: 'http://foo.com', headers: { 'X-API-Key': 'bar' } }); × Search results Close Documentation generated by JSDoc 3.4.3 using the DocStrap template. "},"module-components.html":{"id":"module-components.html","title":"Module: components","body":" arco Modules ajaxcomponentsindexrouterselectorsstatestore Module: components Source: components.js, line 27 Methods &lt;inner&gt; createComponent(PassedComponent [, options]) create a simple component where props are rendered Parameters: Name Type Argument Default Description PassedComponent Component | function component to wrap options Object &lt;optional&gt; {} options to apply to the HOC created by arco Source: components.js, line 334 Returns: Type Component | function Example import createComponent from 'arco'; const OPTIONS = { onButtonClick() { alert('hello!'); } }; const Foo = ({onButtonClick}) =&gt; { return ( &lt;button onClick={onButtonClick} type=&quot;button&quot; &gt; Click me! &lt;/button&gt; ); }; export default createComponent(Foo, OPTIONS); × Search results Close Documentation generated by JSDoc 3.4.3 using the DocStrap template. "},"module-index.html":{"id":"module-index.html","title":"Module: index","body":" arco Modules ajaxcomponentsindexrouterselectorsstatestore Module: index Source: index.js, line 61 Methods &lt;inner&gt; render(Component, element, store) render the passed component with the provided store Parameters: Name Type Description Component React.Component component to render in element element HTMLElement HTML element to render Component inside of store Object redux store to pass to all components Source: index.js, line 65 Example import { render } from 'arco'; import App from './App'; import store from './store'; render(( &lt;App/&gt; ), document.querySelector('#app'), store); × Search results Close Documentation generated by JSDoc 3.4.3 using the DocStrap template. "},"module-router.html":{"id":"module-router.html","title":"Module: router","body":" arco Modules ajaxcomponentsindexrouterselectorsstatestore Module: router Source: router.js, line 33 Methods &lt;inner&gt; createHistory( [history] [, memoryHistoryOptions]) pass the internal react-router pieces necessary to build a custom history Parameters: Name Type Argument Default Description history function | string &lt;optional&gt; browser type of history to create memoryHistoryOptions Object &lt;optional&gt; options specific to creating a memory history Source: router.js, line 37 Returns: Type Object Example import { createHistory } from 'arco'; // create using the string shorthand // valid values are &quot;browser&quot;, &quot;hash&quot;, &quot;memory&quot; const history = createHistory('browser'); // or with a custom function const history = createHistory(({hashHistory, useRouterHistory}) =&gt; { return useRouterHistory(hashHistory)({ queryKey: false }); }); × Search results Close Documentation generated by JSDoc 3.4.3 using the DocStrap template. "},"module-selectors.html":{"id":"module-selectors.html","title":"Module: selectors","body":" arco Modules ajaxcomponentsindexrouterselectorsstatestore Module: selectors Source: selectors.js, line 16 Methods &lt;inner&gt; createSelector(properties [, getComputedValue] [, customMemoize] [, customMemoizeOptions]) based on the array of properties and the reducer passed create a selector Parameters: Name Type Argument Default Description properties Array.&lt;string&gt; | Object properties to retrieve from state getComputedValue function &lt;optional&gt; getIdentityValue method to use for getting the computed value from the properties customMemoize function &lt;optional&gt; null custom memoizer function to use in place of the default customMemoizeOptions function &lt;optional&gt; null additional options for using the custom memoizer option Source: selectors.js, line 123 Returns: Type function Example import { createSelector } from 'arco'; const hasBaz = createSelector(['foo.bar[0].baz'], (baz) =&gt; { return !!baz; }); hasBaz({foo: {bar: [{ baz: 'Here!'}]}}); // true hasBaz({foo: {bar: [{ baz: 'Here!'}]}}); // true, pulled from cache × Search results Close Documentation generated by JSDoc 3.4.3 using the DocStrap template. "},"module-state.html":{"id":"module-state.html","title":"Module: state","body":" arco Modules ajaxcomponentsindexrouterselectorsstatestore Module: state Source: state.js, line 25 Methods &lt;inner&gt; createAction(name [, payloadCreator] [, metaCreator]) action creator helper that will return the redux-actions action build based on its parameters Parameters: Name Type Argument Default Description name string name of the action payloadCreator function &lt;optional&gt; getIdentityValue method to handle the passing of the payload metaCreator function | null &lt;optional&gt; null method to handle any additional metadata Source: state.js, line 128 Returns: Type function Example import { createModule } from 'arco'; const module = createModule('foo'); const action = module.createAction('SET_NAME'); &lt;inner&gt; createAsyncAction(name, payloadHandler) async action creator helper that creates a distinct action for each status with the status passed via payload, and injects the functions for each Parameters: Name Type Description name string name of the action payloadHandler function method to handle the passing of the payload Source: state.js, line 180 Returns: Type function Example import { createModule, get } from 'arco'; const module = createModule('foo'); const action = module.createAsyncAction('GET_STUFF', (lifecycle, otherData) =&gt; { const { onError, onRequest, onSuccess } = lifecycle; return (dispatch) =&gt; { dispatch(onRequest(otherData)); // otherData is passed as payload, PENDING is passed as status in meta return get('/foo') .then((data) =&gt; { dispatch(onSuccess(data)); // data is passed as payload, SUCCESS is passed as status in meta }) .catch((error) =&gt; { dispatch(onError(error)); // error is passed as payload, ERROR is passed as status in meta }); }; }); &lt;inner&gt; createModule(namespace) create a module which has actions and a reducer, and has create methods for them Parameters: Name Type Description namespace string namespace for the module Source: state.js, line 335 Returns: Type Object Example import { createModule } from 'arco'; const appModule = createModule('app'); &lt;inner&gt; createReducer(initialState, handler) reducer creator that will accept the initialState and the handler of that function, either as standard function or as redux-actions map Parameters: Name Type Description initialState Object initial state to hydrate store with handler function method to handle state updates Source: state.js, line 273 Returns: Type function Example import { getActionConstants } from 'arco'; import module, { setName } from './actions'; const INITIAL_STATE = { name: '' }; // use the handleActions method from redux-actions module.createReducer(INITIAL_STATE, (state, { [setName](state, {payload}) { return { ...state, name: payload }; } }); // or use the traditional reducer function method, which requires converting the actions toString module.createReducer(INITIAL_STATE, (state, {payload, type}) =&gt; { switch (type) { case `${setName}`: return { ...state, name: payload }; default: return state; } }); &lt;inner&gt; getActionConstants(namespace) get the constants for the actions of a given namespace Parameters: Name Type Description namespace Object | string module or namespace that action constants are a member of Source: state.js, line 77 Returns: Type Object Example import { getActionConstants } from 'arco'; // use the string namespace value const ACTION_TYPES = getActionContents('app'); // or a predefined module const ACTION_TYPES = getActionContents(appModule); &lt;inner&gt; getModules(namespace) get the module for the given namespace, or all modules if none Parameters: Name Type Description namespace string namespace of module to retrieve Source: state.js, line 377 Returns: Type Object Example import { getModules } from 'arco'; const allModules = getModules(); const appModule = getModules('app'); × Search results Close Documentation generated by JSDoc 3.4.3 using the DocStrap template. "},"module-store.html":{"id":"module-store.html","title":"Module: store","body":" arco Modules ajaxcomponentsindexrouterselectorsstatestore Module: store Source: store.js, line 29 Methods &lt;inner&gt; createStore(modules [, autoRestore], history [, initialState] [, middlewares] [, thunk]) create a store based on the options passed Parameters: Name Type Argument Default Description modules Array.&lt;(Object|function())&gt; array of modules or reducers to use in the store creation autoRestore boolean &lt;optional&gt; false whether the state should be kept in sessionStorage and automatically restored history Object history object to use for creation of the store initialState Object &lt;optional&gt; {} state to hydrate the store with upon creation middlewares Array.&lt;(Object|function())&gt; &lt;optional&gt; [] array of middlewares to use in the store creation thunk boolean &lt;optional&gt; true whether to include redux-thunk in the middlewares used in the store creation Source: store.js, line 144 Returns: Type Store Example import { createStore } from 'arco'; import appModule from 'modules/app'; import fooModule from 'modules/foo'; import barModule from 'modules/bar'; const store = createStore([appModule, fooModule, barModule], { shouldRestoreState: true }); × Search results Close Documentation generated by JSDoc 3.4.3 using the DocStrap template. "}}
    </script>

    <script type="text/javascript">
        $(document).ready(function() {
            Searcher.init();
        });

        $(window).on("message", function(msg) {
            var msgData = msg.originalEvent.data;

            if (msgData.msgid != "docstrap.quicksearch.start") {
                return;
            }

            var results = Searcher.search(msgData.searchTerms);

            window.parent.postMessage({"results": results, "msgid": "docstrap.quicksearch.done"}, "*");
        });
    </script>
</body>
</html>

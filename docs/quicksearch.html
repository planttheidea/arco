<html>
<head>
</head>
<body style="background: transparent;">
    <script src="scripts/docstrap.lib.js"></script>
    <script src="scripts/lunr.min.js"></script>
    <script src="scripts/fulltext-search.js"></script>

    <script type="text/x-docstrap-searchdb">
    {"state.js.html":{"id":"state.js.html","title":"Source: state.js","body":" arco Modules ajaxcomponentsindexrouterselectorsstatestore Classes Component Tutorials ActionsAjaxComponentsHistoryModulesReducersRenderingRouterSelectorsStore Source: state.js // external dependencies import isFunction from 'lodash/isFunction'; import isPlainObject from 'lodash/isPlainObject'; import isString from 'lodash/isString'; import noop from 'lodash/noop'; import { createAction as createReduxAction, handleActions } from 'redux-actions'; // selectors import { getIdentityValue } from './selectors'; // constants import { ERROR_TYPES, STATUS } from './constants'; // utils import { testMetaHandler, testParameter, testReducerHandler } from './utils'; let moduleCache = {}; /** * @module state */ /** * @private * * @function asyncActionStatusCreator * * @description * create action that will dispatch with the error status as meta * * @param {string} status status to provide for the action * @returns {function(): {status: string}} */ export const asyncActionStatusCreator = (status) =&gt; { return () =&gt; { return { status }; }; }; /** * @private * * @function createNamespacedName * * @description * create the namespaced version of the action name * * @param {string} namespace namespace of the module * @param {string} name name of the action * @returns {string} */ export const createNamespacedName = (namespace, name) =&gt; { return `${namespace}/${name}`; }; /** * @private * * @function getCreateAction * * @description * get the create action creator for a given namespace * * @param {string} namespace namespace action will reside in * @returns {function} */ export const getCreateAction = (namespace) =&gt; { /** * @function createAction * * @description * action creator helper that will return the redux-actions * action build based on its parameters * * @example * import { * createModule * } from 'arco'; * * const module = createModule('foo'); * * const action = module.createAction('SET_NAME'); * * @param {string} name name of the action * @param {function} [payloadCreator=getIdentityValue] method to handle the passing of the payload * @param {function|null} [metaCreator=null] method to handle any additional metadata * @returns {function} */ return (name, payloadCreator = getIdentityValue, metaCreator = null) =&gt; { testParameter(name, isString, 'Name of action must be a string.', ERROR_TYPES.TYPE); testParameter(payloadCreator, isFunction, 'Payload handler must be a function.', ERROR_TYPES.TYPE); testParameter(payloadCreator, isFunction, 'Payload handler must be a function.', ERROR_TYPES.TYPE); testParameter(metaCreator, testMetaHandler, 'meta handler must be a function.', ERROR_TYPES.TYPE); const constantName = createNamespacedName(namespace, name); const action = createReduxAction(constantName, payloadCreator, metaCreator); moduleCache[namespace].actions[name] = { action, constantName }; return action; }; }; /** * @private * * @function getCreateAsyncAction * * @description * get the create async action creator for a given namespace * * @param {string} namespace namespace action will reside in * @returns {function} */ export const getCreateAsyncAction = (namespace) =&gt; { const createAction = getCreateAction(namespace); /** * @function createAsyncAction * * @description * async action creator helper that creates a distinct action for each * status with the status passed via payload, and injects the functions * for each * * @example * import { * createModule, * get * } from 'arco'; * * const module = createModule('foo'); * * const action = module.createAsyncAction('GET_STUFF', (lifecycle, otherData) =&gt; { * const { * onError, * onRequest, * onSuccess * } = lifecycle; * * return (dispatch) =&gt; { * dispatch(onRequest(otherData)); * // otherData is passed as payload, PENDING is passed as status in meta * * return get('/foo') * .then((data) =&gt; { * dispatch(onSuccess(data)); * // data is passed as payload, SUCCESS is passed as status in meta * }) * .catch((error) =&gt; { * dispatch(onError(error)); * // error is passed as payload, ERROR is passed as status in meta * }); * }; * }); * * @param {string} name name of the action * @param {function} payloadHandler method to handle the passing of the payload * @returns {function} */ return (name, payloadHandler) =&gt; { testParameter(name, isString, 'Name of action must be a string.', ERROR_TYPES.TYPE); testParameter(payloadHandler, isFunction, 'Payload handler must be a function.', ERROR_TYPES.TYPE); const onError = createAction(name, getIdentityValue, asyncActionStatusCreator(STATUS.ERROR)); const onRequest = createAction(name, getIdentityValue, asyncActionStatusCreator(STATUS.PENDING)); const onSuccess = createAction(name, getIdentityValue, asyncActionStatusCreator(STATUS.SUCCESS)); const lifecycle = { onError, onRequest, onSuccess }; const action = (...args) =&gt; { return payloadHandler(lifecycle, ...args); }; //in case you want different handlers in the reducer for each action status action.onError = onError; action.onRequest = onRequest; action.onSuccess = onSuccess; const actionName = createNamespacedName(namespace, name); /** * set the toString to return the name passed, so it will work * with createReducer * * @returns {string} */ action.toString = () =&gt; { return actionName; }; moduleCache[namespace].actions[name].action = action; return action; }; }; /** * @private * * @function getCreateReducer * * @description * get the reducer creator for a given namespace * * @param {string} namespace namespace reducer will reside in * @returns {function} */ export const getCreateReducer = (namespace) =&gt; { /** * @function createReducer * * @description * reducer creator that will accept the initialState and the handler of that * function, either as standard function or as redux-actions map * * @example * import { * getActionConstants * } from 'arco'; * * import module, { * setName * } from './actions'; * * const INITIAL_STATE = { * name: '' * }; * * // use the handleActions method from redux-actions * module.createReducer(INITIAL_STATE, (state, { * [setName](state, {payload}) { * return { * ...state, * name: payload * }; * } * }); * * // or use the traditional reducer function method, which requires converting the actions toString * module.createReducer(INITIAL_STATE, (state, {payload, type}) =&gt; { * switch (type) { * case `${setName}`: * return { * ...state, * name: payload * }; * * default: * return state; * } * }); * * @param {Object} initialState initial state to hydrate store with * @param {function} handler method to handle state updates * @returns {function} */ return (initialState, handler) =&gt; { let reducer; testParameter(handler, testReducerHandler, 'Reducer must either be an object or a function.', ERROR_TYPES.TYPE); if (isFunction(handler)) { reducer = (state = initialState, action) =&gt; { return handler(state, action); }; } else if (isPlainObject(handler)) { reducer = handleActions(handler, initialState); } moduleCache[namespace].reducer = reducer; reducer.namespace = namespace; return reducer; }; }; /** * @function createModule * * @description * create a module which has actions and a reducer, and has create methods for them * * @example * import { * createModule * } from 'arco'; * * const appModule = createModule('app'); * * @param {string} namespace namespace for the module * @returns {Object} */ export const createModule = (namespace) =&gt; { testParameter(namespace, isString, 'Namespace provided must be a string.', ERROR_TYPES.TYPE); if (moduleCache[namespace]) { throw new ReferenceError(`Namespace ${namespace} is already in use.`, ERROR_TYPES.REFERENCE); } moduleCache[namespace] = { actions: {}, reducer: noop }; const createAction = getCreateAction(namespace); const createAsyncAction = getCreateAsyncAction(); const createReducer = getCreateReducer(namespace); return { createAction, createAsyncAction, createReducer, namespace }; }; /** * @function getModules * * @description * get the module for the given namespace, or all modules if none * * @example * import { * getModules * } from 'arco'; * * const allModules = getModules(); * const appModule = getModules('app'); * * @param {string} namespace namespace of module to retrieve * @returns {Object} */ export const getModules = (namespace) =&gt; { if (isString(namespace)) { return moduleCache[namespace]; } return moduleCache; }; export default createModule; Ã— Search results Close Documentation generated by JSDoc 3.4.3 using the DocStrap template. "},"Component.js.html":{"id":"Component.js.html","title":"Source: Component.js","body":" arco Modules ajaxcomponentsindexrouterselectorsstatestore Classes Component Tutorials ActionsAjaxComponentsHistoryModulesReducersRenderingRouterSelectorsStore Source: Component.js // external dependencies import bind from 'lodash/bind'; import React from 'react'; import { findDOMNode } from 'react-dom'; // utils import { getPropsAndMethods, memoize } from './utils'; /** * @class Component * @augments React.Component * * @classdesc * extension of React.Component which includes some helper utilities and allows for state * * @example * * import createComponent, { * Component * } from 'arco'; * * // can still create your lifecycle methods as external methods * const componentDidUpdate = function(props) { * console.log('Updated with props: ', props); * console.log('Updated with state: ', this.state); // state accessed through this * }; * * class Foo extends Component { * state = { * foo: null * }; * * onClickButton = () =&gt; { * this.setState({ * foo: 'bar' * }); * }; * * render(props) { * return ( * &lt;button * onClick={this.onClickButton} * type=&quot;button&quot; * &gt; * Click me * &lt;/button&gt; * ); * } * } */ export class Component extends React.Component { constructor(...args) { super(...args); this._getPropsToPass = memoize(getPropsAndMethods); this._localMethods = { getDOMNode: this.getDOMNode }; this.render = bind(this.render, this, this.props, this.context); } /** * @function getDOMNode * * @memberOf Component * @instance * * @description * if the selector is passed, query the component to find the matching DOM element, * else return the DOM element of the component itself * * @example * import createComponent, { * Component * } from 'arco'; * * // function instead of arrow function to retain the &quot;this&quot; * const componentDidMount = function() { * const div = this.getDOMNode(); // gets the top-level div node * const input = this.getDOMNode('.input'); // gets the input child node * }; * * class Foo extends Component { * * render() { * return ( * &lt;div&gt; * &lt;input * className=&quot;input&quot; * type=&quot;text&quot; * /&gt; * &lt;/div&gt; * ); * } * } * * export default createComponent(Foo, { * componentDidMount * }); * * @param {string} [selector] CSS selector to query component for * @returns {HTMLElement} */ getDOMNode = (selector) =&gt; { const domNode = findDOMNode(this); if (!!selector) { return domNode.querySelector(selector); } return domNode; }; } export default Component; Ã— Search results Close Documentation generated by JSDoc 3.4.3 using the DocStrap template. "},"ajax.js.html":{"id":"ajax.js.html","title":"Source: ajax.js","body":" arco Modules ajaxcomponentsindexrouterselectorsstatestore Classes Component Tutorials ActionsAjaxComponentsHistoryModulesReducersRenderingRouterSelectorsStore Source: ajax.js // external dependencies import axios from 'axios'; import isString from 'lodash/isString'; import isPlainObject from 'lodash/isPlainObject'; // utils import { testParameter } from './utils'; // constants import { ERROR_TYPES } from './constants'; /** * @module ajax */ /** * @function createInstance * * @description * create a unique axios instance based on the options passed * * @example * import { * createInstance * } from 'arco'; * * const ajaxInstance = createInstance({ * baseURL: 'http://foo.com' * }); * * @param {Object} [options={}] axios options to pass to the instance when created * @returns {AxiosInstance} */ export const createInstance = (options = {}) =&gt; { return axios.create(options); }; /* eslint-disable valid-jsdoc */ /** * @function setDefaults * * @description * set the defaults for the axios instance * * @example * import { * setDefaults * } from 'arco'; * * setDefaults({ * baseURL: 'http://foo.com', * headers: { * 'X-API-Key': 'bar' * } * }); * * @param {Object} [options={}] * @param {string} [options.baseURL] base URL for all axios calls * @param {Object} [options.headers] headers to add to all axios calls * @returns {Axios} */ /* eslint-enable */ export const setDefaults = ({baseURL, headers} = {}) =&gt; { if (!!baseURL) { testParameter(baseURL, isString, 'baseURL provided is not a string.', ERROR_TYPES.TYPE); axios.defaults.baseURL = baseURL; } if (!!headers) { testParameter(headers, isPlainObject, 'headers provided are not an object.', ERROR_TYPES.TYPE); const currentHeaders = axios.defaults.headers; const { common, del, get, head, patch, post, put } = headers; axios.defaults.headers.common = { ...currentHeaders.common, ...common }; axios.defaults.headers.delete = { ...currentHeaders.delete, ...del }; axios.defaults.headers.get = { ...currentHeaders.get, ...get }; axios.defaults.headers.head = { ...currentHeaders.head, ...head }; axios.defaults.headers.patch = { ...currentHeaders.patch, ...patch }; axios.defaults.headers.post = { ...currentHeaders.post, ...post }; axios.defaults.headers.put = { ...currentHeaders.put, ...put }; } return axios; }; /** * @function del * * @description * perform DELETE call via AJAX * * @example * import { * del * } from 'arco'; * * const response = del('/foo/1234'); * * @param {string} url URL to submit DELETE to * @param {Object} [config] custom configuration options for specific call * @returns {Promise} */ export const del = axios.delete; /** * @function get * * @description * perform GET call via AJAX * * @example * import { * get * } from 'arco'; * * const response = get('/foo/1234'); * * @param {string} url URL to submit GET to * @param {Object} [config] custom configuration options for specific call * @returns {Promise} */ export const get = axios.get; /** * @function head * * @description * perform HEAD call via AJAX * * @example * import { * head * } from 'arco'; * * const response = head('/foo'); * * @param {string} url URL to submit HEAD to * @param {Object} [config] custom configuration options for specific call * @returns {Promise} */ export const head = axios.head; /** * @function patch * * @description * perform PATCH call via AJAX * * @example * import { * patch * } from 'arco'; * * const response = patch('/foo/123'); * * @param {string} url URL to submit PATCH to * @param {Object} [data] data to include in the request body on the call * @param {Object} [config] custom configuration options for specific call * @returns {Promise} */ export const patch = axios.patch; /** * @function post * * @description * perform POST call via AJAX * * @example * import { * post * } from 'arco'; * * const response = post('/foo/123', { * bar: 'baz' * }); * * @param {string} url URL to submit POST to * @param {Object} [data] data to include in the request body on the call * @param {Object} [config] custom configuration options for specific call * @returns {Promise} */ export const post = axios.post; /** * @function put * * @description * perform PUT call via AJAX * * @example * import { * put * } from 'arco'; * * const response = put('/foo/123', { * bar: 'foo' * }); * * @param {string} url URL to submit PUT to * @param {Object} [data] data to include in the request body on the call * @param {Object} [config] custom configuration options for specific call * @returns {Promise} */ export const put = axios.put; export default { createInstance, del, get, head, patch, post, put, setDefaults }; Ã— Search results Close Documentation generated by JSDoc 3.4.3 using the DocStrap template. "},"components.js.html":{"id":"components.js.html","title":"Source: components.js","body":" arco Modules ajaxcomponentsindexrouterselectorsstatestore Classes Component Tutorials ActionsAjaxComponentsHistoryModulesReducersRenderingRouterSelectorsStore Source: components.js // external dependencies import isFunction from 'lodash/isFunction'; import React from 'react'; import { connect } from 'react-redux'; // constants import { ERROR_TYPES, keys } from './constants'; // utils import { getComponentMethods, isReactClass, isReactEvent, testParameter } from './utils'; // components import Component from './Component'; /** * @module components */ /** * @private * * @function addPropertyIfExists * * @description * add to component the property if the value exists * * @param {Component} component component to add the property to * @param {string} property property name * @param {*} value value of the property to assign * @returns {Component} */ export const addPropertyIfExists = (component, property, value) =&gt; { if (!!value) { component[property] = value; } return component; }; /** * @private * * @function assignChildContext * * @description * assign the child context to the component passed * * @param {Component} component component to assign child context to * @param {function} getChildContext method for getting child context * @param {boolean} [canAccessThis=false] can the method access the instance * @returns {Component} */ export const assignChildContext = (component, getChildContext, canAccessThis = false) =&gt; { testParameter(getChildContext, isFunction, 'getChildContext is not a function', ERROR_TYPES.TYPE); const boundThis = canAccessThis ? component : undefined; component.getChildContext = () =&gt; { return getChildContext.call(boundThis, component.props, component.context); }; return component; }; /** * @private * * @function connectIfReduxPropertiesExist * * @description * if there are redux-specific options present, connect the component * * @param {Component} component component to connect to redux if applicable * @param {function|Object} mapDispatchToProps functions wrapped in dispatch to pass as props * @param {function} mapStateToProps state to pass as props * @param {function} mergeProps function to merge store state with local props * @param {Object} reduxOptions additional options to pass to @connect * @returns {Component} */ export const connectIfReduxPropertiesExist = (component, { mapDispatchToProps, mapStateToProps, mergeProps, reduxOptions }) =&gt; { if (mapDispatchToProps || mapStateToProps || mergeProps || reduxOptions) { return connect(mapStateToProps, mapDispatchToProps, mergeProps, reduxOptions)(component); } return component; }; /** * @private * * @function getAllPropsToPass * * @description * combine normal props with local methods for all props to pass * * @param {Component} component component to get the props and local methods from * @param {function} [component._getPropsToPass] method to retrieve combined props * @param {Object} [component._localMethods] local methods assigned to the HOC instance * @param {Object} [component.props] props passed to the HOC * @returns {Object} */ export const getAllPropsToPass = (component) =&gt; { return component._getPropsToPass(component.props, component._localMethods); }; /** * @private * * @function assignLifecycleMethods * * @description * assign the lifecycle methods to the instance * * @param {Component|StatefulComponent} component component to assign lifecycle methods to * @param {function} component._getPropsToPass function to retrieve all props to pass down * @param {Object} component._localMethods local methods to add to props passed down * @param {Object} component.props actual props to pass down * @param {Object} lifecycleMethods map of lifecycle methods * @param {boolean} [canAccessThis=false] can the method access the instance * @returns {Component} */ export const assignLifecycleMethods = (component, lifecycleMethods, canAccessThis = false) =&gt; { const appliedThis = canAccessThis ? component : undefined; keys(lifecycleMethods).forEach((key) =&gt; { testParameter(lifecycleMethods[key], isFunction, `${key} is not a function, skipping assignment to instance.`, ERROR_TYPES.TYPE); component[key] = (props) =&gt; { let args = [getAllPropsToPass(component)]; if (props) { args.push(props); } args.push(component.context); return lifecycleMethods[key].apply(appliedThis, args); }; }); return component; }; /** * @private * * @function assignLocalMethods * * @description * assign the local methods to the instance * * @param {Component} component component to assign local methods to * @param {function} component._getPropsToPass function to retrieve all props to pass down * @param {Object} component._localMethods local methods to add to props passed down * @param {Object} localMethods map of methods accessible locally through props * @returns {Component} */ export const assignLocalMethods = (component, localMethods) =&gt; { keys(localMethods).forEach((key) =&gt; { component._localMethods[key] = (...args) =&gt; { const [ event, ...restOfArgs ] = args; const isFirstArgEvent = isReactEvent(event); let argsToPass = [getAllPropsToPass(component)]; if (isFirstArgEvent) { argsToPass.unshift(event); } argsToPass.push(component.context); argsToPass.push(isFirstArgEvent ? restOfArgs : args); return localMethods[key].apply(undefined, argsToPass); }; }); return component; }; /** * @private * * @function getStatefulComponent * * @description * get the stateful component that, if the options are passed, is connected to redux * * @param {Component} PassedComponent component wrapped by arco * @param {Object} options options to apply to the HOC created by arco * @returns {Component} */ export const getStatefulComponent = (PassedComponent, options) =&gt; { const { childContextTypes, contextTypes, getChildContext, mapDispatchToProps: mapDispatchToPropsIgnored, mapStateToProps: mapStateToPropsIgnored, mergeProps: mergePropsIgnored, propTypes, reduxOptions: reduxOptionsIgnored, ...restOfOptions } = options; const { lifecycleMethods } = getComponentMethods(restOfOptions); class StatefulComponent extends PassedComponent { constructor(...args) { super(...args); assignLifecycleMethods(this, lifecycleMethods, true); if (childContextTypes &amp;&amp; getChildContext) { assignChildContext(this, getChildContext, true); } } } addPropertyIfExists(StatefulComponent, 'childContextTypes', childContextTypes); addPropertyIfExists(StatefulComponent, 'contextTypes', contextTypes); addPropertyIfExists(StatefulComponent, 'propTypes', propTypes); return connectIfReduxPropertiesExist(StatefulComponent, options); }; /** * @private * * @function getStatelessComponent * * @description * get the stateless component HOC that has local and lifecycle methods based on * the options, as well as possibly being connected to redux * * @param {Component|function} PassedComponent component wrapped by arco * @param {Object} options options to apply to the HOC created by arco * @returns {Component} */ export const getStatelessComponent = (PassedComponent, options) =&gt; { const { childContextTypes, contextTypes, getChildContext, mapDispatchToProps: mapDispatchToPropsIgnored, mapStateToProps: mapStateToPropsIgnored, mergeProps: mergePropsIgnored, propTypes, reduxOptions: reduxOptionsIgnored, ...restOfOptions } = options; const { lifecycleMethods, localMethods } = getComponentMethods(restOfOptions); addPropertyIfExists(PassedComponent, 'contextTypes', contextTypes); addPropertyIfExists(PassedComponent, 'propTypes', propTypes); class StatelessComponent extends Component { constructor(...args) { super(...args); assignLifecycleMethods(this, lifecycleMethods); assignLocalMethods(this, localMethods); if (childContextTypes &amp;&amp; getChildContext) { assignChildContext(this, getChildContext); } } render() { const propsToPass = this._getPropsToPass(this.props, this._localMethods); return ( &lt;PassedComponent {...propsToPass}/&gt; ); } } addPropertyIfExists(StatelessComponent, 'childContextTypes', childContextTypes); return connectIfReduxPropertiesExist(StatelessComponent, options); }; /** * @function createComponent * * @description * create a simple component where props are rendered * * @example * import createComponent from 'arco'; * * const OPTIONS = { * onButtonClick() { * alert('hello!'); * } * }; * * const Foo = ({onButtonClick}) =&gt; { * return ( * &lt;button * onClick={onButtonClick} * type=&quot;button&quot; * &gt; * Click me! * &lt;/button&gt; * ); * }; * * export default createComponent(Foo, OPTIONS); * * @param {Component|function} PassedComponent component to wrap * @param {Object} [options={}] options to apply to the HOC created by arco * @returns {Component|function(Component): Component} */ export const createComponent = (PassedComponent, options = {}) =&gt; { if (isReactClass(PassedComponent)) { return getStatefulComponent(PassedComponent, options); } return getStatelessComponent(PassedComponent, options); }; export default createComponent; Ã— Search results Close Documentation generated by JSDoc 3.4.3 using the DocStrap template. "},"index.js.html":{"id":"index.js.html","title":"Source: index.js","body":" arco Modules ajaxcomponentsindexrouterselectorsstatestore Classes Component Tutorials ActionsAjaxComponentsHistoryModulesReducersRenderingRouterSelectorsStore Source: index.js // external dependencies import isElement from 'lodash/isElement'; import isPlainObject from 'lodash/isPlainObject'; import React, { PropTypes } from 'react'; import ReactDOM from 'react-dom'; import { Provider } from 'react-redux'; // components import { Component } from './Component'; import { createComponent } from './components'; // modules import createModule, { getActionConstants } from './state'; // store import createStore from './store'; // ajax import ajax, { del, get, head, patch, post, put } from './ajax'; // router import { IndexLink, IndexRedirect, IndexRoute, Link, Route, Router, RouterContext, applyRouterMiddleware, createRoutes, createHistory, formatPattern, locationShape, match, routerShape, syncHistoryWithImmutableStore, syncHistoryWithStore, withRouter } from './router.js'; // selectors import createSelector from './selectors'; // utils import { isReactElement, testParameter } from './utils'; // constants import { ERROR_TYPES } from './constants'; /** * @module index */ /** * @private * * @function getAppContainerDiv * * @description * get the div to render into and inject it into the DOM * * @returns {Element} */ export const getAppContainerDiv = () =&gt; { const div = document.createElement('div'); div.id = 'app-container'; document.body.appendChild(div); return div; }; /** * @function render * * @description * render the passed component with the provided store * * @example * import { * render * } from 'arco'; * * import App from './App'; * import store from './store'; * * render(( * &lt;App/&gt; * ), document.querySelector('#app'), store); * * @param {ReactElement} component component to render in element * @param {HTMLElement} element HTML element to render Component inside of * @param {Object} store redux store to pass to all components */ export const render = (component, element, store) =&gt; { testParameter(component, isReactElement, 'Component passed is not a valid React element.', ERROR_TYPES.TYPE); testParameter(element, isElement, 'Element passed to render into is not a valid HTML element.', ERROR_TYPES.TYPE); testParameter(store, isPlainObject, 'Store passed is not a valid arco store.', ERROR_TYPES.TYPE); if (element.tagName.toLowerCase() === 'body') { element = getAppContainerDiv(); } ReactDOM.render(( &lt;Provider store={store}&gt; {component} &lt;/Provider&gt; ), element); }; export {Component}; export {createComponent}; export {PropTypes}; export {createModule}; export {getActionConstants}; export {createStore}; export {ajax}; export {del}; export {get}; export {head}; export {patch}; export {post}; export {put}; export {IndexLink}; export {IndexRedirect}; export {IndexRoute}; export {Link}; export {Route}; export {Router}; export {RouterContext}; export {applyRouterMiddleware}; export {createRoutes}; export {createHistory}; export {formatPattern}; export {locationShape}; export {match}; export {routerShape}; export {syncHistoryWithImmutableStore}; export {syncHistoryWithStore}; export {withRouter}; export {React}; export {createSelector}; export default createComponent; Ã— Search results Close Documentation generated by JSDoc 3.4.3 using the DocStrap template. "},"router.js.html":{"id":"router.js.html","title":"Source: router.js","body":" arco Modules ajaxcomponentsindexrouterselectorsstatestore Classes Component Tutorials ActionsAjaxComponentsHistoryModulesReducersRenderingRouterSelectorsStore Source: router.js // external dependencies import isFunction from 'lodash/isFunction'; import { IndexLink, IndexRedirect, IndexRoute, Link, Route, Router, RouterContext, applyRouterMiddleware, browserHistory, createMemoryHistory, createRoutes, formatPattern, hashHistory, locationShape, match, routerShape, useRouterHistory, withRouter } from 'react-router'; import { syncHistoryWithStore } from 'react-router-redux'; // utils import { testParameter } from './utils'; // constants import { ERROR_TYPES, HISTORY_TYPES } from './constants'; /** * @module router */ /** * @function createHistory * * @description * pass the internal react-router pieces necessary to build a custom history * * @example * import createHashHistory from 'history/lib/createHashHistory'; * import { * createHistory * } from 'arco'; * * // create using the string shorthand * // valid values are &quot;browser&quot;, &quot;hash&quot;, &quot;memory&quot; * const history = createHistory('browser'); * * // or with a custom function * const history = createHistory((useRouterHistory) =&gt; { * return useRouterHistory(createHashHistory)({ * queryKey: false * }); * }); * * @param {function|'browser'|'hash'|'memory'} [history=browser] type of history to create * @param {Object} [memoryHistoryOptions] options specific to creating a memory history * @returns {Object} */ export const createHistory = (history = HISTORY_TYPES.BROWSER, memoryHistoryOptions) =&gt; { if (history === HISTORY_TYPES.BROWSER) { return browserHistory; } if (history === HISTORY_TYPES.HASH) { return hashHistory; } if (history === HISTORY_TYPES.MEMORY) { return createMemoryHistory(memoryHistoryOptions); } if (isFunction(history)) { return history(useRouterHistory); } testParameter( history, isFunction, 'History does not match any known values, and you are not attempting to create your own custom history.', ERROR_TYPES.REFERENCE ); }; /** * @function syncHistoryWithImmutableStore * * @description * convenience function to sync your history to your store when it is using redux-immutable * * @example * import { * createHistory, * createStore, * syncHistoryWithImmutableStore * } from 'arco'; * * import modules from 'modules'; * * const history = createHistory(); * const store = createStore(modules, { * isImmutable: true * }); * * const syncedHistory = syncHistoryWithImmutableStore(history, store); * * @param {Object} history history that the application uses * @param {Object} store redux store for the application state * @param {Object} [options={}] additional options for syncHistoryWithStore * @returns {Object} */ export const syncHistoryWithImmutableStore = (history, store, options = {}) =&gt; { return syncHistoryWithStore(history, store, { ...options, selectLocationState(state) { return state.get('routing').toJS(); } }); }; export {IndexLink}; export {IndexRedirect}; export {IndexRoute}; export {Link}; export {Route}; export {Router}; export {RouterContext}; export {applyRouterMiddleware}; export {createRoutes}; export {formatPattern}; export {locationShape}; export {match}; export {routerShape}; export {syncHistoryWithStore}; export {withRouter}; export default createHistory; Ã— Search results Close Documentation generated by JSDoc 3.4.3 using the DocStrap template. "},"selectors.js.html":{"id":"selectors.js.html","title":"Source: selectors.js","body":" arco Modules ajaxcomponentsindexrouterselectorsstatestore Classes Component Tutorials ActionsAjaxComponentsHistoryModulesReducersRenderingRouterSelectorsStore Source: selectors.js // external dependencies import get from 'lodash/get'; import isArray from 'lodash/isArray'; import isFunction from 'lodash/isFunction'; import isPlainObject from 'lodash/isPlainObject'; import { createSelector as createReselectSelector, createSelectorCreator } from 'reselect'; // utils import { testParameter } from './utils'; // constants import { ERROR_TYPES } from './constants'; /** * @module selectors */ /** * @private * * @function createIdentitySelector * * @description * create selector to retrieve identity based on deeply-nested values * * @param {function|string} property property string to convert to nested path * @returns {function(Object): *} */ export const createIdentitySelector = (property) =&gt; { if (isFunction(property)) { return property; } return (passedState) =&gt; { return get(passedState, property); }; }; /** * @private * * @function getIdentityValue * * @description * pass-through function to return the value passed to it * * @param {*} value value to pass through * @returns {*} */ export const getIdentityValue = (value) =&gt; { return value; }; /** * @private * * @function getSelectorGenerator * * @description * get the generator for the selector based on the customMemozer being a function or not * * @param {function} customMemoizer memoizer function to use instead of the default * @param {Object} options additional options to use when creating the selector generator * @returns {function} */ export const getSelectorGenerator = (customMemoizer, options) =&gt; { return isFunction(customMemoizer) ? createSelectorCreator(customMemoizer, ...options) : createReselectSelector; }; /** * @private * * @function getStructuredValue * * @description * build a structured value to return for structured selectors * * @param {Array&lt;string&gt;} keys array of keys to use for values in structured selector * @returns {function(Array&lt;*&gt;): Object} */ export const getStructuredValue = (keys) =&gt; { return (...values) =&gt; { return keys.reduce((structuredValue, key, keyIndex) =&gt; { structuredValue[key] = values[keyIndex]; return structuredValue; }, {}); }; }; /** * @private * * @function getStandardSelector * * @description * get the standard selector type (single value) * * @param {Array&lt;string&gt;} paths array of strings denoting nested paths of values in state * @param {function} selectorGenerator method to use for generating selector * @param {function} getValue method to use for computing the value to return * @returns {function} */ export const getStandardSelector = (paths, selectorGenerator, getValue) =&gt; { const selectors = paths.map(createIdentitySelector); return selectorGenerator(selectors, getValue); }; /* eslint-disable valid-jsdoc */ /** * @private * * @function getStructuredSelector * * @description * get the structured selector based on the properties passed * * @param {Array&lt;string&gt;} keys array of keys to use for values in structured selector * @param {Array&lt;string&gt;} paths array of strings denoting nested paths to use for values in structured selector * @param {function} selectorGenerator method to use for generating selector * @returns {function} */ /* eslint-enable */ export const getStructuredSelector = ({keys, paths}, selectorGenerator) =&gt; { if (keys.length !== paths.length) { throw new ReferenceError('Keys and properties arrays must be the same length.'); } const selectors = paths.map(createIdentitySelector); return selectorGenerator(selectors, getStructuredValue(keys)); }; /** * @function createSelector * * @description * based on the array of properties and the reducer passed * create a selector * * @example * import { * createSelector * } from 'arco'; * * const hasBaz = createSelector(['foo.bar[0].baz'], (baz) =&gt; { * return !!baz; * }); * * hasBaz({foo: {bar: [{ baz: 'Here!'}]}}); // true * hasBaz({foo: {bar: [{ baz: 'Here!'}]}}); // true, pulled from cache * * @param {Array&lt;string&gt;|{keys: Array&lt;string&gt;, paths: Array&lt;string&gt;}} properties properties to retrieve from state * @param {function} [getComputedValue=getIdentityValue] method for getting the computed value from the properties * @param {function} [customMemoizer=null] custom memoizer function to use in place of the default * @param {Object} [customMemoizerOptions={}] additional options for using the custom memoizer option * @returns {function} */ export const createSelector = ( properties = [], getComputedValue = getIdentityValue, customMemoizer = null, customMemoizerOptions = {} ) =&gt; { const selectorGenerator = getSelectorGenerator(customMemoizer, customMemoizerOptions); if (isPlainObject(properties)) { return getStructuredSelector(properties, selectorGenerator); } testParameter(properties, isArray, 'Properties passed must be either an object of keys and paths or an ' + 'array of paths.', ERROR_TYPES.TYPE); testParameter(getComputedValue, isFunction, 'Computed value passed must be a function.', ERROR_TYPES.TYPE); return getStandardSelector(properties, selectorGenerator, getComputedValue); }; export default createSelector; Ã— Search results Close Documentation generated by JSDoc 3.4.3 using the DocStrap template. "},"store.js.html":{"id":"store.js.html","title":"Source: store.js","body":" arco Modules ajaxcomponentsindexrouterselectorsstatestore Classes Component Tutorials ActionsAjaxComponentsHistoryModulesReducersRenderingRouterSelectorsStore Source: store.js // external dependencies import Immutable from 'immutable'; import isArray from 'lodash/isArray'; import isFunction from 'lodash/isFunction'; import isPlainObject from 'lodash/isPlainObject'; import { LOCATION_CHANGE, routerReducer } from 'react-router-redux'; import { applyMiddleware, combineReducers, compose, createStore as createReduxStore } from 'redux'; import { combineReducers as combineImmutableReducers } from 'redux-immutable'; import reduxThunk from 'redux-thunk'; // modules import { getModules } from './state'; // constants import { ARCO_STATE_KEY, ERROR_TYPES } from './constants'; // utils import { testParameter } from './utils'; const IMMUTABLE_ROUTING_REDUCER_INITIAL_STATE = Immutable.fromJS({ locationBeforeTransitions: null }); export const immutableRouterReducer = (state = IMMUTABLE_ROUTING_REDUCER_INITIAL_STATE, {payload, type}) =&gt; { if (type === LOCATION_CHANGE) { return state.set('locationBeforeTransitions', payload); } return state; }; /** * @module store */ /** * @private * * @function addWindowUnloadListener * * @description * add a listener to beforeunload to save the state in sessionStorage * * @param {Object} store state to store in sessionStorage for retrieval on refresh */ export const addWindowUnloadListener = (store) =&gt; { window.addEventListener('beforeunload', () =&gt; { const state = store.getState(); window.sessionStorage.setItem(ARCO_STATE_KEY, JSON.stringify(state)); }); }; /** * @private * * @function createRestorableStateStore * * @description * create a store that will automatically save and restore the state * in session storage * * @param {function} reducers all reducers to be used in the store creation * @param {function} enhancers all enhancers to be used in the store creation * @param {Object} initialState state to hydrate the store with on creation * @returns {Store} */ export const createRestorableStateStore = (reducers, enhancers, initialState) =&gt; { const stateString = window &amp;&amp; window.sessionStorage.getItem(ARCO_STATE_KEY); const preloadedState = stateString ? JSON.parse(stateString) : {...initialState}; const store = createReduxStore(reducers, preloadedState, enhancers); if (window) { addWindowUnloadListener(store); } return store; }; /** * @private * * @function getComposedEnhancers * * @description * get the enhancers used in the store based on the middlewares passed * and if thunk is to be included * * @param {Array&lt;function&gt;} middlewares array of middlewares to be applied to the store * @param {boolean} hasThunk whether to use redux-thunk middleware * @returns {function|undefined} */ export const getComposedEnhancers = (middlewares = [], hasThunk) =&gt; { let enhancers = [...middlewares]; if (hasThunk) { enhancers.unshift(reduxThunk); } if (!enhancers.length) { return; } const composeEnhancers = (window &amp;&amp; window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__) || compose; return composeEnhancers(applyMiddleware(...enhancers)); }; /** * @private * * @function getReducerMap * * @description * get the map of reducers based on the modules / reducers * passed and whether or not to include the routing reducer * * @param {Array&lt;Object|function&gt;} modules array of modules or reducers to populate the store with * @param {boolean} hasHistory whether a history object exists, and therefore should have a router reducer * @param {boolean} isImmutable whether store is immutable or not * @returns {Object} */ export const getReducerMap = (modules, hasHistory, isImmutable) =&gt; { const moduleMap = modules.reduce((reducers, passedReducer) =&gt; { const namespace = passedReducer.namespace; const module = isFunction(passedReducer) ? passedReducer : getModules(namespace); if (!module) { return reducers; } if (isFunction(module)) { return { ...reducers, [namespace]: module }; } return { ...reducers, [namespace]: module.reducer }; }, {}); if (!hasHistory) { return moduleMap; } const routing = !isImmutable ? routerReducer : immutableRouterReducer; return { ...moduleMap, routing }; }; /** * @function createStore * * @description * create a store based on the options passed * * @example * import { * createStore * } from 'arco'; * * import appModule from 'modules/app'; * import fooModule from 'modules/foo'; * import barModule from 'modules/bar'; * * const store = createStore([appModule, fooModule, barModule], { * shouldRestoreState: true * }); * * @param {Array&lt;Object|function&gt;} modules array of modules or reducers to use in the store creation * @param {boolean} [autoRestore=false] whether the state should be kept in sessionStorage and automatically restored * @param {Object} history history object to use for creation of the store * @param {Object} [initialState={}] state to hydrate the store with upon creation * @param {boolean} [isImmutable=false] whether to use redux-immutable when combining reducers (if using ImmutableJS) * @param {Array&lt;Object|function&gt;} [middlewares=[]] array of middlewares to use in the store creation * @param {boolean} [thunk=true] whether to include redux-thunk in the middlewares used in the store creation * @returns {Store} */ export const createStore = (modules, { autoRestore = false, history, initialState = {}, isImmutable = false, middlewares = [], thunk = true } = {}) =&gt; { testParameter(modules, isArray, 'The first parameter must be an array of modules.', ERROR_TYPES.TYPE); testParameter(initialState, isPlainObject, 'initialState must be an object.', ERROR_TYPES.TYPE); testParameter(middlewares, isArray, 'middlewares must be an array of functions.', ERROR_TYPES.TYPE); const reducerCombiner = isImmutable ? combineImmutableReducers : combineReducers; const mapOfReducers = getReducerMap(modules, !!history, isImmutable); const allReducers = reducerCombiner(mapOfReducers); const enhancers = getComposedEnhancers(middlewares, thunk); if (!autoRestore) { return createReduxStore(allReducers, initialState, enhancers); } return createRestorableStateStore(allReducers, enhancers, initialState); }; export default createStore; Ã— Search results Close Documentation generated by JSDoc 3.4.3 using the DocStrap template. "},"modules.list.html":{"id":"modules.list.html","title":"Modules","body":" arco Modules ajaxcomponentsindexrouterselectorsstatestore Classes Component Tutorials ActionsAjaxComponentsHistoryModulesReducersRenderingRouterSelectorsStore Modules Classes Component Ã— Search results Close Documentation generated by JSDoc 3.4.3 using the DocStrap template. "},"classes.list.html":{"id":"classes.list.html","title":"Classes","body":" arco Modules ajaxcomponentsindexrouterselectorsstatestore Classes Component Tutorials ActionsAjaxComponentsHistoryModulesReducersRenderingRouterSelectorsStore Classes Classes Component Ã— Search results Close Documentation generated by JSDoc 3.4.3 using the DocStrap template. "},"tutorials.list.html":{"id":"tutorials.list.html","title":"Tutorials","body":" arco Modules ajaxcomponentsindexrouterselectorsstatestore Classes Component Tutorials ActionsAjaxComponentsHistoryModulesReducersRenderingRouterSelectorsStore Tutorials Classes Component Ã— Search results Close Documentation generated by JSDoc 3.4.3 using the DocStrap template. "},"index.html":{"id":"index.html","title":"Index","body":" arco Modules ajaxcomponentsindexrouterselectorsstatestore Classes Component Tutorials ActionsAjaxComponentsHistoryModulesReducersRenderingRouterSelectorsStore arco 0.1.0 A React+Redux framework with standards, conventions, and far less boilerplate Installation $ npm i arco --saveSummary arco is a framework designed to streamline a lot of the architectural configuration of a React application by providing several web-standard packages built-in, as well as an API that is built to keep boilerplate minimal. The following packages are all included as part of arco: axios for AJAX calls react for views react-dom for rendering into the browser react-router for routing react-router-redux for react-router bindings into redux redux for state management redux-actions for simplified redux action creation redux-immutable for use of redux with stores based on ImmutableJS redux-thunk for asynchronous actions (optional) reselect for memoized selectors Additionally, the following concepts are applied through convention: ducks for encapsulated functionality modules of actions / reducer flux-standard-action for formatting of actions in a standard way arco provides a layer of abstraction over the use of these so that you can focus on implementation, but with the same sort of flexibility you would expect from each of these packages directly. Think of it as convention with configuration. Additionally, keeping in line with redux, arco focuses on immutability and pure functions to eliminate side effects and make testing easier. Building an app You can find tutorials on how to create each aspect of an arco app in the &quot;Tutorials&quot; section, or select from below: Actions: actions consumed by your redux store (based on redux-actions) Ajax: make async calls, such as to an API (based on axios) Components: react components that are connected to your store and enhanced by the use of pure functions History: history used with react-router for the single-page application Modules: encapsulated modules that contain redux actions and a reducer to manage them (based on ) Reducers: reducer that contains state of a specific topic in your redux store Rendering: rendering your react views into the DOM Router: render your react views active in the route (based on react-router) Selectors: memoized selectors for computed data to keep your stored state small (based on reselect) Store: your redux store which encompasses the state of your entire application Hello World example // import from one application import createComponent, { createModule, render } from 'arco'; // create a module for a piece of functionality in your state const app = createModule('app'); // create actions for that module const sayHello = app.createAction('SAY_HELLO'); // create a reducer for that module app.createReducer({hasSaidHello: false}, { [sayHello](state) { return { ...state, hasSaidHello: true }; } }); // create your store from an array of modules (or the module's reducers) const store = createStore([app]); // build your components as functional components const App = ({hasSaidHello, sayHello}) =&gt; { return ( &lt;div&gt; &lt;button onClick={sayHello} type=&quot;button&quot;&gt; Say hello &lt;/button&gt; {hasSaidHello &amp;&amp; &lt;h1&gt;Hello World!&lt;/h1&gt;} &lt;/div&gt; ); }; // create the component with options that allow connecting to lifecycle methods and the redux store= const ConnectedApp = createComponent(App, { mapStateToProps({app}) { return app; }, mapDispatchToProps: { sayHello } }); // render in browser, pre-wired with the store render(&lt;ConnectedApp/&gt;, document.body, store);Setup There are a couple things to be aware of when setting up arco for your application. React global arco expects there to be a global React object for it to render components, and if you don't provide it then you will receive a React is not defined error when attempting to render. There are two ways to fix this error: Create a React global With webpack you can use ProviderPlugin With browserify you can use something like browserify-global-shim With &lt;script&gt; you just make sure to put the tag for React first Import React from the arco package whenever creating a component ImmutableJS is not included While it is a common paradigm to pair React applications with the library ImmutableJS, it is not included in arco but is rather considered &quot;opt-in&quot;. There are integration options related to your application's History and Store included in arco, however the package itself is not included in the bundle like react and others are. As such, if you choose to make use of it, you will need to install it yourself. That said, Immutable is installed as a dependency to allow for those integration options, so if you are using a bundler like webpack and are not using immutable, it is recommended to set immutable to be an external in your configuration options. Contributing This project is in its infancy, and many more expansion capabilities are there: Universal app setup Predefined webpack / ESLint / Babel config CLI interface to automate creation of app scaffold I welcome any and all ideas, but especially pull requests. Development Standard stuff, clone the repo and npm install dependencies. The npm scripts available: build =&gt; run webpack to build crio.js with NODE_ENV=development build:minifed =&gt; run webpack to build crio.min.js with NODE_ENV=production dev =&gt; run webpack dev server to run example app (playground!) dist =&gt; runs build and build-minified docs =&gt; builds the docs via jsdoc lint =&gt; run ESLint against all files in the src folder prepublish =&gt; runs compile-for-publish prepublish:compile =&gt; run lint, test, transpile, dist test =&gt; run AVA test functions with NODE_ENV=test test:watch =&gt; same as test, but runs persistent watcher transpile =&gt; run babel against all files in src to create files in lib Ã— Search results Close Documentation generated by JSDoc 3.4.3 using the DocStrap template. "},"Component.html":{"id":"Component.html","title":"Class: Component","body":" arco Modules ajaxcomponentsindexrouterselectorsstatestore Classes Component Tutorials ActionsAjaxComponentsHistoryModulesReducersRenderingRouterSelectorsStore Class: Component Component extension of React.Component which includes some helper utilities and allows for state new Component() Source: Component.js, line 32 Example import createComponent, { Component } from 'arco'; // can still create your lifecycle methods as external methods const componentDidUpdate = function(props) { console.log('Updated with props: ', props); console.log('Updated with state: ', this.state); // state accessed through this }; class Foo extends Component { state = { foo: null }; onClickButton = () =&gt; { this.setState({ foo: 'bar' }); }; render(props) { return ( &lt;button onClick={this.onClickButton} type=&quot;button&quot; &gt; Click me &lt;/button&gt; ); } } Extends React.Component Methods getDOMNode( [selector]) if the selector is passed, query the component to find the matching DOM element, else return the DOM element of the component itself Parameters: Name Type Argument Description selector string &lt;optional&gt; CSS selector to query component for Source: Component.js, line 106 Returns: Type HTMLElement Example import createComponent, { Component } from 'arco'; // function instead of arrow function to retain the &quot;this&quot; const componentDidMount = function() { const div = this.getDOMNode(); // gets the top-level div node const input = this.getDOMNode('.input'); // gets the input child node }; class Foo extends Component { * render() { return ( &lt;div&gt; &lt;input className=&quot;input&quot; type=&quot;text&quot; /&gt; &lt;/div&gt; ); } } export default createComponent(Foo, { componentDidMount }); Ã— Search results Close Documentation generated by JSDoc 3.4.3 using the DocStrap template. "},"module-ajax.html":{"id":"module-ajax.html","title":"Module: ajax","body":" arco Modules ajaxcomponentsindexrouterselectorsstatestore Classes Component Tutorials ActionsAjaxComponentsHistoryModulesReducersRenderingRouterSelectorsStore Module: ajax Source: ajax.js, line 35 Methods &lt;inner&gt; createInstance( [options]) create a unique axios instance based on the options passed Parameters: Name Type Argument Default Description options Object &lt;optional&gt; {} axios options to pass to the instance when created Source: ajax.js, line 39 Returns: Type AxiosInstance Example import { createInstance } from 'arco'; const ajaxInstance = createInstance({ baseURL: 'http://foo.com' }); &lt;inner&gt; del(url [, config]) perform DELETE call via AJAX Parameters: Name Type Argument Description url string URL to submit DELETE to config Object &lt;optional&gt; custom configuration options for specific call Source: ajax.js, line 124 Returns: Type Promise Example import { del } from 'arco'; const response = del('/foo/1234'); &lt;inner&gt; get(url [, config]) perform GET call via AJAX Parameters: Name Type Argument Description url string URL to submit GET to config Object &lt;optional&gt; custom configuration options for specific call Source: ajax.js, line 143 Returns: Type Promise Example import { get } from 'arco'; const response = get('/foo/1234'); &lt;inner&gt; head(url [, config]) perform HEAD call via AJAX Parameters: Name Type Argument Description url string URL to submit HEAD to config Object &lt;optional&gt; custom configuration options for specific call Source: ajax.js, line 162 Returns: Type Promise Example import { head } from 'arco'; const response = head('/foo'); &lt;inner&gt; patch(url [, data] [, config]) perform PATCH call via AJAX Parameters: Name Type Argument Description url string URL to submit PATCH to data Object &lt;optional&gt; data to include in the request body on the call config Object &lt;optional&gt; custom configuration options for specific call Source: ajax.js, line 181 Returns: Type Promise Example import { patch } from 'arco'; const response = patch('/foo/123'); &lt;inner&gt; post(url [, data] [, config]) perform POST call via AJAX Parameters: Name Type Argument Description url string URL to submit POST to data Object &lt;optional&gt; data to include in the request body on the call config Object &lt;optional&gt; custom configuration options for specific call Source: ajax.js, line 201 Returns: Type Promise Example import { post } from 'arco'; const response = post('/foo/123', { bar: 'baz' }); &lt;inner&gt; put(url [, data] [, config]) perform PUT call via AJAX Parameters: Name Type Argument Description url string URL to submit PUT to data Object &lt;optional&gt; data to include in the request body on the call config Object &lt;optional&gt; custom configuration options for specific call Source: ajax.js, line 223 Returns: Type Promise Example import { put } from 'arco'; const response = put('/foo/123', { bar: 'foo' }); &lt;inner&gt; setDefaults( [options]) set the defaults for the axios instance Parameters: Name Type Argument Default Description options Object &lt;optional&gt; {} Properties Name Type Argument Description baseURL string &lt;optional&gt; base URL for all axios calls headers Object &lt;optional&gt; headers to add to all axios calls Source: ajax.js, line 64 Returns: Type Axios Example import { setDefaults } from 'arco'; setDefaults({ baseURL: 'http://foo.com', headers: { 'X-API-Key': 'bar' } }); Ã— Search results Close Documentation generated by JSDoc 3.4.3 using the DocStrap template. "},"module-components.html":{"id":"module-components.html","title":"Module: components","body":" arco Modules ajaxcomponentsindexrouterselectorsstatestore Classes Component Tutorials ActionsAjaxComponentsHistoryModulesReducersRenderingRouterSelectorsStore Module: components Source: components.js, line 48 Methods &lt;inner&gt; createComponent(PassedComponent [, options]) create a simple component where props are rendered Parameters: Name Type Argument Default Description PassedComponent Component | function component to wrap options Object &lt;optional&gt; {} options to apply to the HOC created by arco Source: components.js, line 358 Returns: Type Component | function Example import createComponent from 'arco'; const OPTIONS = { onButtonClick() { alert('hello!'); } }; const Foo = ({onButtonClick}) =&gt; { return ( &lt;button onClick={onButtonClick} type=&quot;button&quot; &gt; Click me! &lt;/button&gt; ); }; export default createComponent(Foo, OPTIONS); Ã— Search results Close Documentation generated by JSDoc 3.4.3 using the DocStrap template. "},"module-index.html":{"id":"module-index.html","title":"Module: index","body":" arco Modules ajaxcomponentsindexrouterselectorsstatestore Classes Component Tutorials ActionsAjaxComponentsHistoryModulesReducersRenderingRouterSelectorsStore Module: index Source: index.js, line 54 Methods &lt;inner&gt; render(component, element, store) render the passed component with the provided store Parameters: Name Type Description component ReactElement component to render in element element HTMLElement HTML element to render Component inside of store Object redux store to pass to all components Source: index.js, line 88 Example import { render } from 'arco'; import App from './App'; import store from './store'; render(( &lt;App/&gt; ), document.querySelector('#app'), store); Ã— Search results Close Documentation generated by JSDoc 3.4.3 using the DocStrap template. "},"module-router.html":{"id":"module-router.html","title":"Module: router","body":" arco Modules ajaxcomponentsindexrouterselectorsstatestore Classes Component Tutorials ActionsAjaxComponentsHistoryModulesReducersRenderingRouterSelectorsStore Module: router Source: router.js, line 31 Methods &lt;inner&gt; createHistory( [history] [, memoryHistoryOptions]) pass the internal react-router pieces necessary to build a custom history Parameters: Name Type Argument Default Description history function | 'browser' | 'hash' | 'memory' &lt;optional&gt; browser type of history to create memoryHistoryOptions Object &lt;optional&gt; options specific to creating a memory history Source: router.js, line 35 Returns: Type Object Example import createHashHistory from 'history/lib/createHashHistory'; import { createHistory } from 'arco'; // create using the string shorthand // valid values are &quot;browser&quot;, &quot;hash&quot;, &quot;memory&quot; const history = createHistory('browser'); // or with a custom function const history = createHistory((useRouterHistory) =&gt; { return useRouterHistory(createHashHistory)({ queryKey: false }); }); &lt;inner&gt; syncHistoryWithImmutableStore(history, store [, options]) convenience function to sync your history to your store when it is using redux-immutable Parameters: Name Type Argument Default Description history Object history that the application uses store Object redux store for the application state options Object &lt;optional&gt; {} additional options for syncHistoryWithStore Source: router.js, line 85 Returns: Type Object Example import { createHistory, createStore, syncHistoryWithImmutableStore } from 'arco'; import modules from 'modules'; const history = createHistory(); const store = createStore(modules, { isImmutable: true }); const syncedHistory = syncHistoryWithImmutableStore(history, store); Ã— Search results Close Documentation generated by JSDoc 3.4.3 using the DocStrap template. "},"module-selectors.html":{"id":"module-selectors.html","title":"Module: selectors","body":" arco Modules ajaxcomponentsindexrouterselectorsstatestore Classes Component Tutorials ActionsAjaxComponentsHistoryModulesReducersRenderingRouterSelectorsStore Module: selectors Source: selectors.js, line 41 Methods &lt;inner&gt; createSelector(properties [, getComputedValue] [, customMemoizer] [, customMemoizerOptions]) based on the array of properties and the reducer passed create a selector Parameters: Name Type Argument Default Description properties Array.&lt;string&gt; | Object properties to retrieve from state getComputedValue function &lt;optional&gt; getIdentityValue method for getting the computed value from the properties customMemoizer function &lt;optional&gt; null custom memoizer function to use in place of the default customMemoizerOptions Object &lt;optional&gt; {} additional options for using the custom memoizer option Source: selectors.js, line 169 Returns: Type function Example import { createSelector } from 'arco'; const hasBaz = createSelector(['foo.bar[0].baz'], (baz) =&gt; { return !!baz; }); hasBaz({foo: {bar: [{ baz: 'Here!'}]}}); // true hasBaz({foo: {bar: [{ baz: 'Here!'}]}}); // true, pulled from cache Ã— Search results Close Documentation generated by JSDoc 3.4.3 using the DocStrap template. "},"module-state.html":{"id":"module-state.html","title":"Module: state","body":" arco Modules ajaxcomponentsindexrouterselectorsstatestore Classes Component Tutorials ActionsAjaxComponentsHistoryModulesReducersRenderingRouterSelectorsStore Module: state Source: state.js, line 38 Methods &lt;inner&gt; createAction(name [, payloadCreator] [, metaCreator]) action creator helper that will return the redux-actions action build based on its parameters Parameters: Name Type Argument Default Description name string name of the action payloadCreator function &lt;optional&gt; getIdentityValue method to handle the passing of the payload metaCreator function | null &lt;optional&gt; null method to handle any additional metadata Source: state.js, line 95 Returns: Type function Example import { createModule } from 'arco'; const module = createModule('foo'); const action = module.createAction('SET_NAME'); &lt;inner&gt; createAsyncAction(name, payloadHandler) async action creator helper that creates a distinct action for each status with the status passed via payload, and injects the functions for each Parameters: Name Type Description name string name of the action payloadHandler function method to handle the passing of the payload Source: state.js, line 151 Returns: Type function Example import { createModule, get } from 'arco'; const module = createModule('foo'); const action = module.createAsyncAction('GET_STUFF', (lifecycle, otherData) =&gt; { const { onError, onRequest, onSuccess } = lifecycle; return (dispatch) =&gt; { dispatch(onRequest(otherData)); // otherData is passed as payload, PENDING is passed as status in meta return get('/foo') .then((data) =&gt; { dispatch(onSuccess(data)); // data is passed as payload, SUCCESS is passed as status in meta }) .catch((error) =&gt; { dispatch(onError(error)); // error is passed as payload, ERROR is passed as status in meta }); }; }); &lt;inner&gt; createModule(namespace) create a module which has actions and a reducer, and has create methods for them Parameters: Name Type Description namespace string namespace for the module Source: state.js, line 322 Returns: Type Object Example import { createModule } from 'arco'; const appModule = createModule('app'); &lt;inner&gt; createReducer(initialState, handler) reducer creator that will accept the initialState and the handler of that function, either as standard function or as redux-actions map Parameters: Name Type Description initialState Object initial state to hydrate store with handler function method to handle state updates Source: state.js, line 251 Returns: Type function Example import { getActionConstants } from 'arco'; import module, { setName } from './actions'; const INITIAL_STATE = { name: '' }; // use the handleActions method from redux-actions module.createReducer(INITIAL_STATE, (state, { [setName](state, {payload}) { return { ...state, name: payload }; } }); // or use the traditional reducer function method, which requires converting the actions toString module.createReducer(INITIAL_STATE, (state, {payload, type}) =&gt; { switch (type) { case `${setName}`: return { ...state, name: payload }; default: return state; } }); &lt;inner&gt; getModules(namespace) get the module for the given namespace, or all modules if none Parameters: Name Type Description namespace string namespace of module to retrieve Source: state.js, line 362 Returns: Type Object Example import { getModules } from 'arco'; const allModules = getModules(); const appModule = getModules('app'); Ã— Search results Close Documentation generated by JSDoc 3.4.3 using the DocStrap template. "},"module-store.html":{"id":"module-store.html","title":"Module: store","body":" arco Modules ajaxcomponentsindexrouterselectorsstatestore Classes Component Tutorials ActionsAjaxComponentsHistoryModulesReducersRenderingRouterSelectorsStore Module: store Source: store.js, line 75 Methods &lt;inner&gt; createStore(modules [, autoRestore], history [, initialState] [, isImmutable] [, middlewares] [, thunk]) create a store based on the options passed Parameters: Name Type Argument Default Description modules Array.&lt;(Object|function())&gt; array of modules or reducers to use in the store creation autoRestore boolean &lt;optional&gt; false whether the state should be kept in sessionStorage and automatically restored history Object history object to use for creation of the store initialState Object &lt;optional&gt; {} state to hydrate the store with upon creation isImmutable boolean &lt;optional&gt; false whether to use redux-immutable when combining reducers (if using ImmutableJS) middlewares Array.&lt;(Object|function())&gt; &lt;optional&gt; [] array of middlewares to use in the store creation thunk boolean &lt;optional&gt; true whether to include redux-thunk in the middlewares used in the store creation Source: store.js, line 196 Returns: Type Store Example import { createStore } from 'arco'; import appModule from 'modules/app'; import fooModule from 'modules/foo'; import barModule from 'modules/bar'; const store = createStore([appModule, fooModule, barModule], { shouldRestoreState: true }); Ã— Search results Close Documentation generated by JSDoc 3.4.3 using the DocStrap template. "},"tutorial-Actions.html":{"id":"tutorial-Actions.html","title":"Tutorial: Actions","body":" arco Modules ajaxcomponentsindexrouterselectorsstatestore Classes Component Tutorials ActionsAjaxComponentsHistoryModulesReducersRenderingRouterSelectorsStore Actions Actions are Flux Standard Actions produced with the scoping of the namespace of the module applied. The creation and use of them is based off of redux-actions. Simple synchronomous actions Synchronomous actions with payload transformation Passing metadata Asynchronomous actions Simple synchronous actions For a synchronous action that simply passes the parameter passed through as payload, action creation is very easy: import module from 'modules/app'; const action = module.createAction('FOO');Synchronous actions with payload transformation If you want to manipulate the payload prior to dispatch, provide the transformation method as the second parameter: import module from 'modules/app'; const action = module.createAction('FOO', (data) =&gt; { return { data }; });Passing metadata If you want to provide additional data that is separate from the payload, pass a third function to the method: import module from 'modules/app'; // undefined second parameter means that the pass-through method from the simple action creation is used for payload const action = module.createAction('FOO', undefined, (data) =&gt; { return { hasData: !!data }; });The meta function will receive the same parameters as the payload function. Asynchronous actions Async actions are a little different, in that they basically serve as a creator of three separate actions for the status of the method. Example: import { get } from 'arco'; import module from 'modules/app'; const action = module.createAsyncAction('FOO', (lifecycle, data) =&gt; { const { onError, onRequest, onSuccess } = lifecycle; // example with redux-thunk return async (dispatch) =&gt; { dispatch(onRequest()); try { const response = await get('/foo'); dispatch(onSuccess(response.data)); } catch (error) { dispatch(onError(error)); } }; });Notice the lifecycle parameter is injected, which includes the actions to dispatch with the status of the call. onRequest dispatches an action with meta set to {status: 'PENDING'} onSuccess dispatches an action with meta set to {status: 'SUCCESS'} onError dispatches an action with meta set to {status: 'ERROR'} In all three cases, any parameter passed to the action is the payload. Ã— Search results Close Documentation generated by JSDoc 3.4.3 using the DocStrap template. "},"tutorial-Ajax.html":{"id":"tutorial-Ajax.html","title":"Tutorial: Ajax","body":" arco Modules ajaxcomponentsindexrouterselectorsstatestore Classes Component Tutorials ActionsAjaxComponentsHistoryModulesReducersRenderingRouterSelectorsStore Ajax The absence of an AJAX library is one of the biggest complains about the react ecosystem, so arco made the inclusion of a solid, easy-to-use library a top focus. We selected axios based on its ease of use, promised-based API, tiny footprint, and strong usage across modern web projects. AJAX methods Setup Custom instances AJAX methods We have mainly provided simple pass-through exports for the standard methods supported by axios: delete (aliased as del due to delete being a reserved keyword) get head patch post put For more information about how to use these methods, please consult the axios API documentation. You can individually import these methods individually or as an object collection: import { get, post } from 'arco'; get(...); post(...); // or import { ajax } from 'arco'; ajax.get(...); ajax.post(...);Setup If you want to set defaults for all your AJAX calls, you can run setDefaults at the beginning of your application: import { ajax } from 'arco'; ajax.setDefaults({ baseURL: 'http://foo.com', headers: { common: { 'X-API-KEY': 'foo' } } });These options will be deeply merged with the existing options. Make sure to run this at the beginning of your application so all future AJAX calls reflect these defaults. Custom instances You can also create a unique instance with a specific configuration, say if you are querying different servers that expect different values for the same headers. import { ajax } from 'arco'; const customInstance = ajax.createInstance({ headers: { put: { 'FOO': 'bar' } } }); Ã— Search results Close Documentation generated by JSDoc 3.4.3 using the DocStrap template. "},"tutorial-Components.html":{"id":"tutorial-Components.html","title":"Tutorial: Components","body":" arco Modules ajaxcomponentsindexrouterselectorsstatestore Classes Component Tutorials ActionsAjaxComponentsHistoryModulesReducersRenderingRouterSelectorsStore Components Components are comprised of two pieces, a react component and the options passed that enhance that component. Import Creating a component Options Lifecycle methods Child context Local methods Additional methods Stateful components Import For any component creation, you simply need to import the createComponent method from arco: import createComponent from 'arco';Creating a component If you want to build a simple presentational component, you do not need to provide any options: const Foo = (props) =&gt; { ... }; export default createComponent(Foo);Nothing crazy here, pretty much the same as you normally would do for functional components, but the real benefits come when we add some options. Options There are a number of options that can be passed as a second parameter to createComponent which enhance the capabilities of ordinary functional components in react. Lifecycle methods All lifecycle methods other than constructor are supported, and they have been modified to receive props and context as parameters so that they can be built as pure functions. Example: // most lifecycle methods will receive the current props and context const componentDidMount = (props, context) =&gt; { console.log('Mounted with props: ', props); console.log('Mounted with context: ', context); }; // componentWillReceiveProps gets props, nextProps, context, and nextContext const componentWillReceiveProps = (props, nextProps, context, nextContext) =&gt; { console.log('Will update from current props: ', props, ' to new props: ', nextProps); console.log('Will update from current context: ', context, ' to new context: ', nextContext); }; // componentDidUpdate gets the same treatment as componentWillReceiveProps, but with previous instead of next const componentDidUpdate = (props, previousProps, context, previousContext) =&gt; { console.log('Update with current props: ', props, ' from previous props: ', previousProps); console.log('Update with current context: ', context, ' from previous context: ', previousContext); };And to apply them: export default createComponent(Foo, { componentDidMount, componentWillReceiveProps, componentDidUpdate });Child context You can also add child context to the component by providing the same kind of parameters as options: import createComponent, { PropTypes } from 'arco'; const childContextTypes = { foo: PropTypes.string }; // props and context are injected just like lifecycle methods const getChildContext = (props, context) =&gt; { return { foo: 'bar' }; };And apply them in the same way: export default createComponent(Foo, { childContextTypes, getChildContext });Local methods In addition to react-specific methods and properties, you can provide local methods that will have the props and context injected in the same way as the lifecycle methods. These are especially useful when providing event methods to elements in the component: const mapDispatchToProps = { someAction }; // props and context are injected into the method following the event const onClickButton = (event, props) =&gt; { props.someAction('data'); }; const Foo = ({onClickButton}) =&gt; { return ( &lt;button onClick={onClickButton}&gt; Click me! &lt;/button&gt; ) }; export default createComponent(Foo, { mapDispatchToProps, onClickButton });While you can use this for any instance method, it is advised to only use this for event-driven methods. You can just as easily create pure functions that exist outside of the options to perform additional computation. Additional methods On top of the methods that you can pass in as options, there are some methods that are included for you. getDOMNode([selector]): HTMLElement This method accepts an optional selector, which if provided will retrieve a child node of the component that matches the selector, else returns the node of the component itself. const getInput = ({getDOMNode}) =&gt; { return getDOMNode('input'); }; const resetInputIfEscape = (event, props) =&gt; { if (event.which === 27) { const input = getInput(props); input.value = ''; } }; const Foo = ({resetInputIfEscape}) =&gt; { return ( &lt;div&gt; &lt;label&gt; Some input &lt;/label&gt; &lt;input onKeyDown={resetInputIfEscape} type=&quot;text&quot; /&gt; &lt;/div&gt; ); }; export default createComponent(Foo, { resetInputIfEscape })Stateful components While function components are the preferred usage of arco, you can use stateful components as well. import createComponent, { Component } from 'arco'; const componentDidMount = (props) =&gt; { console.log('Mounted with props: ', props); }; class Foo extends Component { state = { foo: '' }; render() { const { foo } = this.state; if (foo) { return ( &lt;span&gt;foo&lt;/span&gt; ); } return ( &lt;span&gt;bar&lt;/span&gt; ); } } export default createComponent(Foo, { componentDidMount });StatefulComponent is basically a mirror image of React.Component, so consult the standard React documentation for usage. There are two things to note, however: Stateful components can receive pure lifecycle methods as options, however local and additional methods are not available as options The render method of StatefulComponent receives both props and context of the component as parameters (state is not provided) Ã— Search results Close Documentation generated by JSDoc 3.4.3 using the DocStrap template. "},"tutorial-History.html":{"id":"tutorial-History.html","title":"Tutorial: History","body":" arco Modules ajaxcomponentsindexrouterselectorsstatestore Classes Component Tutorials ActionsAjaxComponentsHistoryModulesReducersRenderingRouterSelectorsStore History Creating a history object is useful if your application uses routing (which most do). As such, arco makes the creation of various types of history as painless as possible: Standard Custom Use with ImmutableJS Standard For most applications, use of a standard history is sufficient for routing. import { createHistory } from 'arco'; export default createHistory('hash');There are three types of standard histories: browser (default) = HTML5 History API, using clean URLs and pushState (Modern browsers) hash = Include hash in URL (IE9-) memory = In-memory history that does not interact with the browser URL Can also pass a second parameter of options to createHistory Custom In the case you want to use a custom history, you can instead pass a function to createHistory and return your own: import createHashHistory from 'history/lib/createHashHistory'; import { createHistory } from 'arco'; export default createHistory((useRouterHistory) =&gt; { return useRouterHistory(createHashHistory)({ queryKey: false }); });Use with ImmutableJS If you create your Reducer with isImmutable set to true and you want to sync your history with that store, you should use the provided syncHistoryWithImmutableStore function instead of the standard syncHistoryWithStore. import { syncHistoryWithImmutableStore } from 'arco'; import history from './history'; import store from './store'; const syncedHistory = syncHistoryWithImmutableStore(history, store);This is a convenience function that performs the standard syncing method that redux-immutable requires. Ã— Search results Close Documentation generated by JSDoc 3.4.3 using the DocStrap template. "},"tutorial-Modules.html":{"id":"tutorial-Modules.html","title":"Tutorial: Modules","body":" arco Modules ajaxcomponentsindexrouterselectorsstatestore Classes Component Tutorials ActionsAjaxComponentsHistoryModulesReducersRenderingRouterSelectorsStore Modules Modules are the encapsulation of a specific piece of state functionality, meaning the redux reducer that manages a particular piece of state and the actions that update that reducer. Creating a module is as simple as calling createModule with a namespace: import { createModule } from 'arco'; export default createModule('app');You can have as many modules as you need for your application, as they translate one-to-one to the reducers in your store. If you are a fan of the ducks pattern, you can include your actions and reducer into a single file very easily: import { createModule } from 'arco'; const module = createModule('foo'); const action = module.createAction('SET_BAR'); const INITIAL_STATE = { bar: '' }; const reducer = module.createReducer(INITIAL_STATE, { [action](state, {payload}) { return { ...state, bar: payload } } }); export default module;For specifics about creating actions and the reducer from the module, consult the Actions and Reducers tutorials. Ã— Search results Close Documentation generated by JSDoc 3.4.3 using the DocStrap template. "},"tutorial-Reducers.html":{"id":"tutorial-Reducers.html","title":"Tutorial: Reducers","body":" arco Modules ajaxcomponentsindexrouterselectorsstatestore Classes Component Tutorials ActionsAjaxComponentsHistoryModulesReducersRenderingRouterSelectorsStore Reducers Like Actions, Reducers are created with the scope of a namespaced module, however there are two ways to create a Reducer. Traditional method Shorthand method Traditional method For those most comfortable with the traditional way to create a reducer, you can use the classic functional method: import { createStore } from 'arco'; import module, { setName } from 'modules/app'; const INITIAL_STATE = { name: null }; export default module.createReducer(INITIAL_STATE, ({payload, type}) =&gt; { switch (type) { case `${setName}`: return { ...state, name: payload }; default: return state; } });Notice the way you obtain the type matching; importing the function and converting it to a string will return the namespaced type that is dispatched for that action. Shorthand method A more concise way to manage the actions is the use of the shorthand mapping method based off of handleActions in redux-actions. import { createStore } from 'arco'; import module, { setName } from 'modules/app'; const INITIAL_STATE = { name: null }; export default module.createReducer(INITIAL_STATE, { [setName](state, {payload}) { return { ...state, payload }; } });Same result, but far less code to write. Ã— Search results Close Documentation generated by JSDoc 3.4.3 using the DocStrap template. "},"tutorial-Rendering.html":{"id":"tutorial-Rendering.html","title":"Tutorial: Rendering","body":" arco Modules ajaxcomponentsindexrouterselectorsstatestore Classes Component Tutorials ActionsAjaxComponentsHistoryModulesReducersRenderingRouterSelectorsStore Rendering Using the included render function is very similar to the one used in react-dom, however it accepts the additional parameter of store: import { render } from 'arco'; import App from 'components/App'; import store from 'constants/store'; render(( &lt;App/&gt; ), document.body, store);Internally, the Component is wrapped with the Provider in react-redux so that the store is automatically available. One additional thing to note is that unlike in standard react, document.body is a valid HTML element to render to. Ã— Search results Close Documentation generated by JSDoc 3.4.3 using the DocStrap template. "},"tutorial-Router.html":{"id":"tutorial-Router.html","title":"Tutorial: Router","body":" arco Modules ajaxcomponentsindexrouterselectorsstatestore Classes Component Tutorials ActionsAjaxComponentsHistoryModulesReducersRenderingRouterSelectorsStore Router The use of the Router mechanisms are the exact same as those in react-router, we simply pass through all the available components. As such, here are the links for all the setup examples you should need to get rolling: Introduction Full API Route configuration Route matching Index Routes and Links Ã— Search results Close Documentation generated by JSDoc 3.4.3 using the DocStrap template. "},"tutorial-Selectors.html":{"id":"tutorial-Selectors.html","title":"Tutorial: Selectors","body":" arco Modules ajaxcomponentsindexrouterselectorsstatestore Classes Component Tutorials ActionsAjaxComponentsHistoryModulesReducersRenderingRouterSelectorsStore Selectors Selectors are an incredibly powerful tool for optimizing data computation, and can also greatly reduce the amount of data you need to store in state. They rely on immutable data structures, only updating if the parameters passed have changed, else they keep a cached value and return immediately. The only complaint is that there is a decent amount of code that you need to write in order to produce one, so arco tries to simplify it a bit. import { createSelector } from 'arco'; const getFooBar = createSelector(['foo', 'bar[0].baz[1].bar'], (foo, bar) =&gt; { return `${foo} ${bar}`; }); const state = { foo: 'foo', bar: [ { baz: [ 'foo', { bar: 'bar' } ] } ] }; getFooBar(state); // returns &quot;foo bar&quot; after computing it getFooBar(state); // returns &quot;foo bar&quot; from cache, as nothing changedThe first parameter is an array of properties that you want to retrieve from state, where if they are nested then you provide the full path to the value desired as a string. Internally, arco will retrieve those nested values for use as parameters in the second (function) parameter. If you wish to compose selectors, then simply provide the selector in place of the string path, and the result of that selector will be used for retrieving the paramter instead. Ã— Search results Close Documentation generated by JSDoc 3.4.3 using the DocStrap template. "},"tutorial-Store.html":{"id":"tutorial-Store.html","title":"Tutorial: Store","body":" arco Modules ajaxcomponentsindexrouterselectorsstatestore Classes Component Tutorials ActionsAjaxComponentsHistoryModulesReducersRenderingRouterSelectorsStore Store The store receives an array of either reducers or full modules, and also accepts a number of options to automatically enhance the store. Options autoRestore history initialState middlewares thunk import { createHistory, createStore } from 'arco'; import appReducer from 'modules/app/appReducer'; import fooModule from 'modules/foo'; // array can either have reducers or full modules const modules = [ appReducer, fooModule ]; export default createStore(modules, { history: createHistory() });Options autoRestore boolean, defaults to false If set to true, will store the complete state in sessionStorage on beforeunload, and restore from sessionStorage on load if it exists. history Object Accepts the history object generated from createHistory, which is explained in more detail in the History tutorial. initialState Object, defaults to {} State to apply to the store by default (equivalent to preloadedState in redux). middlewares Array, defaults to [] Middlewares to apply to the store (equivalent to enhancers in redux). If thunk is set to true, then redux-thunk will be automatically included. thunk boolean, defaults to true If set to false, will prevent the addition of redux-thunk in the list of middlewares applied to the store. Ã— Search results Close Documentation generated by JSDoc 3.4.3 using the DocStrap template. "}}
    </script>

    <script type="text/javascript">
        $(document).ready(function() {
            Searcher.init();
        });

        $(window).on("message", function(msg) {
            var msgData = msg.originalEvent.data;

            if (msgData.msgid != "docstrap.quicksearch.start") {
                return;
            }

            var results = Searcher.search(msgData.searchTerms);

            window.parent.postMessage({"results": results, "msgid": "docstrap.quicksearch.done"}, "*");
        });
    </script>
</body>
</html>
